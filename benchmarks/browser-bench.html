<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BLAKE3 Benchmark</title>
  <style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #08080c;
  --fg: #c8c8d0;
  --pink: #f0f;
  --cyan: #0ff;
  --dim: #333;
}

body {
  font: 14px/1.6 'SF Mono', 'Fira Code', 'Consolas', monospace;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
}

canvas { position: fixed; inset: 0; width: 100%; height: 100%; z-index: -1; }

main {
  max-width: 900px;
  margin: 0 auto;
  padding: 3rem 2rem;
}

h1 {
  font-size: 1.5rem;
  font-weight: 400;
  color: var(--pink);
  margin-bottom: 0.25rem;
  text-shadow: 0 0 30px var(--pink);
}

.sub { color: var(--dim); margin-bottom: 2rem; }

.tags {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
}

.tag {
  font-size: 11px;
  padding: 0.25rem 0.5rem;
  border: 1px solid var(--dim);
  color: var(--dim);
}

.tag.ok { border-color: var(--cyan); color: var(--cyan); }

button {
  font: inherit;
  background: none;
  border: 1px solid var(--pink);
  color: var(--pink);
  padding: 0.5rem 1.5rem;
  cursor: pointer;
  transition: all 0.2s;
}

button:hover { background: var(--pink); color: var(--bg); }
button:disabled { opacity: 0.3; cursor: default; background: none; color: var(--pink); }

#out {
  margin-top: 2rem;
  white-space: pre;
  font-size: 13px;
  line-height: 1.8;
}

.h { color: var(--dim); }
.v { color: var(--fg); }
.best { color: var(--cyan); text-shadow: 0 0 10px var(--cyan); }
.x { color: var(--pink); }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<main>
  <h1>BLAKE3 Benchmark</h1>
  <p class="sub">WebAssembly SIMD performance test</p>
  <div class="tags" id="tags"></div>
  <button id="btn" disabled>run</button>
  <pre id="out"></pre>
</main>

<script>
// — background —
const c = document.getElementById('c');
const gl = c.getContext('webgl');
const W = () => c.width = innerWidth;
const H = () => c.height = innerHeight;
addEventListener('resize', () => { W(); H(); gl.viewport(0, 0, c.width, c.height); });
W(); H();
gl.viewport(0, 0, c.width, c.height);

const vs = `attribute vec2 p; void main() { gl_Position = vec4(p, 0, 1); }`;
const fs = `
precision highp float;
uniform float t;
uniform vec2 r;

float grid(vec2 p, float s) {
  vec2 g = abs(fract(p * s) - 0.5);
  return smoothstep(0.02, 0.0, min(g.x, g.y));
}

void main() {
  vec2 uv = gl_FragCoord.xy / r;
  vec2 p = (uv - 0.5) * vec2(r.x/r.y, 1.0);
  
  float g = grid(p + vec2(0, t * 0.1), 8.0) * 0.15;
  g += grid(p + vec2(0, t * 0.05), 2.0) * 0.08;
  
  vec3 col = vec3(1.0, 0.0, 1.0) * g;
  col += vec3(0.03, 0.03, 0.05);
  
  // vignette
  col *= 1.0 - length(uv - 0.5) * 0.8;
  
  gl_FragColor = vec4(col, 1.0);
}
`;

function sh(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, sh(vs, gl.VERTEX_SHADER));
gl.attachShader(prog, sh(fs, gl.FRAGMENT_SHADER));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
const p = gl.getAttribLocation(prog, 'p');
gl.enableVertexAttribArray(p);
gl.vertexAttribPointer(p, 2, gl.FLOAT, false, 0, 0);

const ut = gl.getUniformLocation(prog, 't');
const ur = gl.getUniformLocation(prog, 'r');

let t0 = performance.now();
(function loop() {
  gl.uniform1f(ut, (performance.now() - t0) / 1000);
  gl.uniform2f(ur, c.width, c.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(loop);
})();
</script>

<script>
var BLAKE3 = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // <stdin>
  var stdin_exports = {};
  __export(stdin_exports, {
    FAST_4_SIMD_SUPPORTED: () => SIMD_SUPPORTED3,
    FAST_SIMD_SUPPORTED: () => SIMD_SUPPORTED2,
    SIMD_SUPPORTED: () => SIMD_SUPPORTED,
    fast4SimdHash: () => hash5,
    fastSimdHash: () => hash4,
    hyperSimdHash: () => hashHyper,
    optimizedHash: () => hash2,
    referenceHash: () => hash,
    simdHash: () => hash3,
    ultraSimdHash: () => hashFast
  });

  // src/constants.ts
  var BLOCK_LEN = 64;
  var CHUNK_LEN = 1024;
  var OUT_LEN = 32;
  var IV = new Uint32Array([
    1779033703,
    // sqrt(2)
    3144134277,
    // sqrt(3)
    1013904242,
    // sqrt(5)
    2773480762,
    // sqrt(7)
    1359893119,
    // sqrt(11)
    2600822924,
    // sqrt(13)
    528734635,
    // sqrt(17)
    1541459225
    // sqrt(19)
  ]);
  var CHUNK_START = 1 << 0;
  var CHUNK_END = 1 << 1;
  var PARENT = 1 << 2;
  var ROOT = 1 << 3;
  var KEYED_HASH = 1 << 4;
  var DERIVE_KEY_CONTEXT = 1 << 5;
  var DERIVE_KEY_MATERIAL = 1 << 6;
  var MSG_PERMUTATION = new Uint8Array([
    2,
    6,
    3,
    10,
    7,
    0,
    4,
    13,
    1,
    11,
    12,
    5,
    9,
    14,
    15,
    8
  ]);
  var MSG_SCHEDULE = (() => {
    const schedule = [];
    let current = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15
    ]);
    schedule.push(current);
    for (let round2 = 1; round2 < 7; round2++) {
      const next = new Uint8Array(16);
      for (let i = 0; i < 16; i++) {
        next[i] = current[MSG_PERMUTATION[i]];
      }
      schedule.push(next);
      current = next;
    }
    return schedule;
  })();

  // src/utils.ts
  function rotr32(x, n) {
    return (x >>> n | x << 32 - n) >>> 0;
  }
  function ctz64(x) {
    if (x === 0n)
      return 64;
    let count = 0;
    while ((x & 1n) === 0n) {
      x >>= 1n;
      count++;
    }
    return count;
  }
  function wordsToBytes(words, byteLength) {
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < byteLength; i += 4) {
      const word = words[i >>> 2];
      bytes[i] = word & 255;
      bytes[i + 1] = word >>> 8 & 255;
      bytes[i + 2] = word >>> 16 & 255;
      bytes[i + 3] = word >>> 24 & 255;
    }
    return bytes;
  }

  // src/reference.ts
  function g(state, a, b, c, d, mx, my) {
    state[a] = state[a] + state[b] + mx >>> 0;
    state[d] = rotr32(state[d] ^ state[a], 16);
    state[c] = state[c] + state[d] >>> 0;
    state[b] = rotr32(state[b] ^ state[c], 12);
    state[a] = state[a] + state[b] + my >>> 0;
    state[d] = rotr32(state[d] ^ state[a], 8);
    state[c] = state[c] + state[d] >>> 0;
    state[b] = rotr32(state[b] ^ state[c], 7);
  }
  function round(state, m) {
    g(state, 0, 4, 8, 12, m[0], m[1]);
    g(state, 1, 5, 9, 13, m[2], m[3]);
    g(state, 2, 6, 10, 14, m[4], m[5]);
    g(state, 3, 7, 11, 15, m[6], m[7]);
    g(state, 0, 5, 10, 15, m[8], m[9]);
    g(state, 1, 6, 11, 12, m[10], m[11]);
    g(state, 2, 7, 8, 13, m[12], m[13]);
    g(state, 3, 4, 9, 14, m[14], m[15]);
  }
  function permute(m) {
    const original = m.slice();
    for (let i = 0; i < 16; i++) {
      m[i] = original[MSG_PERMUTATION[i]];
    }
  }
  function compress(cv, block, counter, blockLen, flags) {
    const m = new Uint32Array(16);
    const view = new DataView(block.buffer, block.byteOffset, block.byteLength);
    for (let i = 0; i < 16; i++) {
      m[i] = view.getUint32(i * 4, true);
    }
    const state = new Uint32Array([
      cv[0],
      cv[1],
      cv[2],
      cv[3],
      // Chaining value
      cv[4],
      cv[5],
      cv[6],
      cv[7],
      IV[0],
      IV[1],
      IV[2],
      IV[3],
      // IV constants
      Number(counter & 0xffffffffn),
      // Counter low
      Number(counter >> 32n & 0xffffffffn),
      // Counter high
      blockLen,
      // Block length
      flags
      // Domain flags
    ]);
    round(state, m);
    permute(m);
    round(state, m);
    permute(m);
    round(state, m);
    permute(m);
    round(state, m);
    permute(m);
    round(state, m);
    permute(m);
    round(state, m);
    permute(m);
    round(state, m);
    for (let i = 0; i < 8; i++) {
      state[i] ^= state[i + 8];
    }
    return state;
  }
  function extractChainingValue(state) {
    return state.slice(0, 8);
  }
  function chainingValue(chunk, chunkCounter, flags) {
    let cv = new Uint32Array(IV);
    let pos = 0;
    const numBlocks = Math.ceil(chunk.length / BLOCK_LEN);
    for (let i = 0; i < numBlocks; i++) {
      const blockStart = pos;
      const blockEnd = Math.min(pos + BLOCK_LEN, chunk.length);
      const blockLen = blockEnd - blockStart;
      const block = new Uint8Array(BLOCK_LEN);
      block.set(chunk.subarray(blockStart, blockEnd));
      let blockFlags = flags;
      if (i === 0)
        blockFlags |= CHUNK_START;
      if (i === numBlocks - 1)
        blockFlags |= CHUNK_END;
      const state = compress(cv, block, chunkCounter, blockLen, blockFlags);
      cv = extractChainingValue(state);
      pos += BLOCK_LEN;
    }
    return cv;
  }
  function parentCv(leftCv, rightCv, flags) {
    const block = new Uint8Array(BLOCK_LEN);
    for (let i = 0; i < 8; i++) {
      const offset = i * 4;
      block[offset] = leftCv[i] & 255;
      block[offset + 1] = leftCv[i] >>> 8 & 255;
      block[offset + 2] = leftCv[i] >>> 16 & 255;
      block[offset + 3] = leftCv[i] >>> 24 & 255;
    }
    for (let i = 0; i < 8; i++) {
      const offset = 32 + i * 4;
      block[offset] = rightCv[i] & 255;
      block[offset + 1] = rightCv[i] >>> 8 & 255;
      block[offset + 2] = rightCv[i] >>> 16 & 255;
      block[offset + 3] = rightCv[i] >>> 24 & 255;
    }
    const state = compress(IV, block, 0n, BLOCK_LEN, flags | PARENT);
    return extractChainingValue(state);
  }
  function parentCvWithRoot(leftCv, rightCv) {
    const block = new Uint8Array(BLOCK_LEN);
    for (let i = 0; i < 8; i++) {
      const offset = i * 4;
      block[offset] = leftCv[i] & 255;
      block[offset + 1] = leftCv[i] >>> 8 & 255;
      block[offset + 2] = leftCv[i] >>> 16 & 255;
      block[offset + 3] = leftCv[i] >>> 24 & 255;
    }
    for (let i = 0; i < 8; i++) {
      const offset = 32 + i * 4;
      block[offset] = rightCv[i] & 255;
      block[offset + 1] = rightCv[i] >>> 8 & 255;
      block[offset + 2] = rightCv[i] >>> 16 & 255;
      block[offset + 3] = rightCv[i] >>> 24 & 255;
    }
    return compress(IV, block, 0n, BLOCK_LEN, PARENT | ROOT);
  }
  function hash(input, outputLength = OUT_LEN) {
    if (input.length === 0) {
      const block = new Uint8Array(BLOCK_LEN);
      const state = compress(IV, block, 0n, 0, CHUNK_START | CHUNK_END | ROOT);
      return wordsToBytes(state, outputLength);
    }
    if (input.length <= CHUNK_LEN) {
      let cv = new Uint32Array(IV);
      let pos2 = 0;
      const numBlocks = Math.ceil(input.length / BLOCK_LEN) || 1;
      for (let i = 0; i < numBlocks; i++) {
        const blockStart = pos2;
        const blockEnd = Math.min(pos2 + BLOCK_LEN, input.length);
        const blockLen = blockEnd - blockStart;
        const block = new Uint8Array(BLOCK_LEN);
        if (blockLen > 0) {
          block.set(input.subarray(blockStart, blockEnd));
        }
        let flags = 0;
        if (i === 0)
          flags |= CHUNK_START;
        if (i === numBlocks - 1)
          flags |= CHUNK_END | ROOT;
        const state = compress(cv, block, 0n, blockLen || 0, flags);
        if (i === numBlocks - 1) {
          return wordsToBytes(state, outputLength);
        }
        cv = extractChainingValue(state);
        pos2 += BLOCK_LEN;
      }
    }
    const cvStack = [];
    let chunkCounter = 0n;
    let pos = 0;
    const totalChunks = Math.ceil(input.length / CHUNK_LEN);
    while (pos + CHUNK_LEN <= input.length) {
      const chunk = input.subarray(pos, pos + CHUNK_LEN);
      const cv = chainingValue(chunk, chunkCounter, 0);
      cvStack.push(cv);
      chunkCounter++;
      let mergeCount = ctz64(chunkCounter);
      while (mergeCount > 0 && cvStack.length > 1) {
        if (chunkCounter === BigInt(totalChunks) && cvStack.length === 2) {
          break;
        }
        const right = cvStack.pop();
        const left = cvStack.pop();
        cvStack.push(parentCv(left, right, 0));
        mergeCount--;
      }
      pos += CHUNK_LEN;
    }
    if (pos < input.length) {
      const chunk = input.subarray(pos);
      const cv = chainingValue(chunk, chunkCounter, 0);
      cvStack.push(cv);
    }
    while (cvStack.length > 2) {
      const right = cvStack.pop();
      const left = cvStack.pop();
      cvStack.push(parentCv(left, right, 0));
    }
    if (cvStack.length === 2) {
      const right = cvStack.pop();
      const left = cvStack.pop();
      const state = parentCvWithRoot(left, right);
      return wordsToBytes(state, outputLength);
    }
    throw new Error("Unexpected state in multi-chunk hash");
  }

  // src/optimized.ts
  var STATE = new Uint32Array(16);
  var BLOCK_WORDS = new Uint32Array(16);
  var CV_BUFFER = new Uint32Array(8);
  var PARENT_BLOCK = new Uint8Array(64);
  function compress2(cv, block, counter, blockLen, flags) {
    const view = new DataView(block.buffer, block.byteOffset, block.byteLength);
    for (let i = 0; i < 16; i++) {
      BLOCK_WORDS[i] = view.getUint32(i * 4, true);
    }
    let s0 = cv[0], s1 = cv[1], s2 = cv[2], s3 = cv[3];
    let s4 = cv[4], s5 = cv[5], s6 = cv[6], s7 = cv[7];
    let s8 = IV[0], s9 = IV[1], s10 = IV[2], s11 = IV[3];
    let s12 = Number(counter & 0xffffffffn);
    let s13 = Number(counter >> 32n & 0xffffffffn);
    let s14 = blockLen;
    let s15 = flags;
    const m = BLOCK_WORDS;
    s0 = s0 + s4 + m[0] >>> 0;
    s12 = (s12 ^ s0) >>> 16 | (s12 ^ s0) << 16 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 12 | (s4 ^ s8) << 20 >>> 0;
    s0 = s0 + s4 + m[1] >>> 0;
    s12 = (s12 ^ s0) >>> 8 | (s12 ^ s0) << 24 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 7 | (s4 ^ s8) << 25 >>> 0;
    s1 = s1 + s5 + m[2] >>> 0;
    s13 = (s13 ^ s1) >>> 16 | (s13 ^ s1) << 16 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 12 | (s5 ^ s9) << 20 >>> 0;
    s1 = s1 + s5 + m[3] >>> 0;
    s13 = (s13 ^ s1) >>> 8 | (s13 ^ s1) << 24 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 7 | (s5 ^ s9) << 25 >>> 0;
    s2 = s2 + s6 + m[4] >>> 0;
    s14 = (s14 ^ s2) >>> 16 | (s14 ^ s2) << 16 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 12 | (s6 ^ s10) << 20 >>> 0;
    s2 = s2 + s6 + m[5] >>> 0;
    s14 = (s14 ^ s2) >>> 8 | (s14 ^ s2) << 24 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 7 | (s6 ^ s10) << 25 >>> 0;
    s3 = s3 + s7 + m[6] >>> 0;
    s15 = (s15 ^ s3) >>> 16 | (s15 ^ s3) << 16 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 12 | (s7 ^ s11) << 20 >>> 0;
    s3 = s3 + s7 + m[7] >>> 0;
    s15 = (s15 ^ s3) >>> 8 | (s15 ^ s3) << 24 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 7 | (s7 ^ s11) << 25 >>> 0;
    s0 = s0 + s5 + m[8] >>> 0;
    s15 = (s15 ^ s0) >>> 16 | (s15 ^ s0) << 16 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 12 | (s5 ^ s10) << 20 >>> 0;
    s0 = s0 + s5 + m[9] >>> 0;
    s15 = (s15 ^ s0) >>> 8 | (s15 ^ s0) << 24 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 7 | (s5 ^ s10) << 25 >>> 0;
    s1 = s1 + s6 + m[10] >>> 0;
    s12 = (s12 ^ s1) >>> 16 | (s12 ^ s1) << 16 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 12 | (s6 ^ s11) << 20 >>> 0;
    s1 = s1 + s6 + m[11] >>> 0;
    s12 = (s12 ^ s1) >>> 8 | (s12 ^ s1) << 24 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 7 | (s6 ^ s11) << 25 >>> 0;
    s2 = s2 + s7 + m[12] >>> 0;
    s13 = (s13 ^ s2) >>> 16 | (s13 ^ s2) << 16 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 12 | (s7 ^ s8) << 20 >>> 0;
    s2 = s2 + s7 + m[13] >>> 0;
    s13 = (s13 ^ s2) >>> 8 | (s13 ^ s2) << 24 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 7 | (s7 ^ s8) << 25 >>> 0;
    s3 = s3 + s4 + m[14] >>> 0;
    s14 = (s14 ^ s3) >>> 16 | (s14 ^ s3) << 16 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 12 | (s4 ^ s9) << 20 >>> 0;
    s3 = s3 + s4 + m[15] >>> 0;
    s14 = (s14 ^ s3) >>> 8 | (s14 ^ s3) << 24 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 7 | (s4 ^ s9) << 25 >>> 0;
    s0 = s0 + s4 + m[2] >>> 0;
    s12 = (s12 ^ s0) >>> 16 | (s12 ^ s0) << 16 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 12 | (s4 ^ s8) << 20 >>> 0;
    s0 = s0 + s4 + m[6] >>> 0;
    s12 = (s12 ^ s0) >>> 8 | (s12 ^ s0) << 24 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 7 | (s4 ^ s8) << 25 >>> 0;
    s1 = s1 + s5 + m[3] >>> 0;
    s13 = (s13 ^ s1) >>> 16 | (s13 ^ s1) << 16 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 12 | (s5 ^ s9) << 20 >>> 0;
    s1 = s1 + s5 + m[10] >>> 0;
    s13 = (s13 ^ s1) >>> 8 | (s13 ^ s1) << 24 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 7 | (s5 ^ s9) << 25 >>> 0;
    s2 = s2 + s6 + m[7] >>> 0;
    s14 = (s14 ^ s2) >>> 16 | (s14 ^ s2) << 16 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 12 | (s6 ^ s10) << 20 >>> 0;
    s2 = s2 + s6 + m[0] >>> 0;
    s14 = (s14 ^ s2) >>> 8 | (s14 ^ s2) << 24 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 7 | (s6 ^ s10) << 25 >>> 0;
    s3 = s3 + s7 + m[4] >>> 0;
    s15 = (s15 ^ s3) >>> 16 | (s15 ^ s3) << 16 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 12 | (s7 ^ s11) << 20 >>> 0;
    s3 = s3 + s7 + m[13] >>> 0;
    s15 = (s15 ^ s3) >>> 8 | (s15 ^ s3) << 24 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 7 | (s7 ^ s11) << 25 >>> 0;
    s0 = s0 + s5 + m[1] >>> 0;
    s15 = (s15 ^ s0) >>> 16 | (s15 ^ s0) << 16 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 12 | (s5 ^ s10) << 20 >>> 0;
    s0 = s0 + s5 + m[11] >>> 0;
    s15 = (s15 ^ s0) >>> 8 | (s15 ^ s0) << 24 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 7 | (s5 ^ s10) << 25 >>> 0;
    s1 = s1 + s6 + m[12] >>> 0;
    s12 = (s12 ^ s1) >>> 16 | (s12 ^ s1) << 16 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 12 | (s6 ^ s11) << 20 >>> 0;
    s1 = s1 + s6 + m[5] >>> 0;
    s12 = (s12 ^ s1) >>> 8 | (s12 ^ s1) << 24 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 7 | (s6 ^ s11) << 25 >>> 0;
    s2 = s2 + s7 + m[9] >>> 0;
    s13 = (s13 ^ s2) >>> 16 | (s13 ^ s2) << 16 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 12 | (s7 ^ s8) << 20 >>> 0;
    s2 = s2 + s7 + m[14] >>> 0;
    s13 = (s13 ^ s2) >>> 8 | (s13 ^ s2) << 24 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 7 | (s7 ^ s8) << 25 >>> 0;
    s3 = s3 + s4 + m[15] >>> 0;
    s14 = (s14 ^ s3) >>> 16 | (s14 ^ s3) << 16 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 12 | (s4 ^ s9) << 20 >>> 0;
    s3 = s3 + s4 + m[8] >>> 0;
    s14 = (s14 ^ s3) >>> 8 | (s14 ^ s3) << 24 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 7 | (s4 ^ s9) << 25 >>> 0;
    s0 = s0 + s4 + m[3] >>> 0;
    s12 = (s12 ^ s0) >>> 16 | (s12 ^ s0) << 16 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 12 | (s4 ^ s8) << 20 >>> 0;
    s0 = s0 + s4 + m[4] >>> 0;
    s12 = (s12 ^ s0) >>> 8 | (s12 ^ s0) << 24 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 7 | (s4 ^ s8) << 25 >>> 0;
    s1 = s1 + s5 + m[10] >>> 0;
    s13 = (s13 ^ s1) >>> 16 | (s13 ^ s1) << 16 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 12 | (s5 ^ s9) << 20 >>> 0;
    s1 = s1 + s5 + m[12] >>> 0;
    s13 = (s13 ^ s1) >>> 8 | (s13 ^ s1) << 24 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 7 | (s5 ^ s9) << 25 >>> 0;
    s2 = s2 + s6 + m[13] >>> 0;
    s14 = (s14 ^ s2) >>> 16 | (s14 ^ s2) << 16 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 12 | (s6 ^ s10) << 20 >>> 0;
    s2 = s2 + s6 + m[2] >>> 0;
    s14 = (s14 ^ s2) >>> 8 | (s14 ^ s2) << 24 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 7 | (s6 ^ s10) << 25 >>> 0;
    s3 = s3 + s7 + m[7] >>> 0;
    s15 = (s15 ^ s3) >>> 16 | (s15 ^ s3) << 16 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 12 | (s7 ^ s11) << 20 >>> 0;
    s3 = s3 + s7 + m[14] >>> 0;
    s15 = (s15 ^ s3) >>> 8 | (s15 ^ s3) << 24 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 7 | (s7 ^ s11) << 25 >>> 0;
    s0 = s0 + s5 + m[6] >>> 0;
    s15 = (s15 ^ s0) >>> 16 | (s15 ^ s0) << 16 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 12 | (s5 ^ s10) << 20 >>> 0;
    s0 = s0 + s5 + m[5] >>> 0;
    s15 = (s15 ^ s0) >>> 8 | (s15 ^ s0) << 24 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 7 | (s5 ^ s10) << 25 >>> 0;
    s1 = s1 + s6 + m[9] >>> 0;
    s12 = (s12 ^ s1) >>> 16 | (s12 ^ s1) << 16 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 12 | (s6 ^ s11) << 20 >>> 0;
    s1 = s1 + s6 + m[0] >>> 0;
    s12 = (s12 ^ s1) >>> 8 | (s12 ^ s1) << 24 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 7 | (s6 ^ s11) << 25 >>> 0;
    s2 = s2 + s7 + m[11] >>> 0;
    s13 = (s13 ^ s2) >>> 16 | (s13 ^ s2) << 16 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 12 | (s7 ^ s8) << 20 >>> 0;
    s2 = s2 + s7 + m[15] >>> 0;
    s13 = (s13 ^ s2) >>> 8 | (s13 ^ s2) << 24 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 7 | (s7 ^ s8) << 25 >>> 0;
    s3 = s3 + s4 + m[8] >>> 0;
    s14 = (s14 ^ s3) >>> 16 | (s14 ^ s3) << 16 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 12 | (s4 ^ s9) << 20 >>> 0;
    s3 = s3 + s4 + m[1] >>> 0;
    s14 = (s14 ^ s3) >>> 8 | (s14 ^ s3) << 24 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 7 | (s4 ^ s9) << 25 >>> 0;
    s0 = s0 + s4 + m[10] >>> 0;
    s12 = (s12 ^ s0) >>> 16 | (s12 ^ s0) << 16 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 12 | (s4 ^ s8) << 20 >>> 0;
    s0 = s0 + s4 + m[7] >>> 0;
    s12 = (s12 ^ s0) >>> 8 | (s12 ^ s0) << 24 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 7 | (s4 ^ s8) << 25 >>> 0;
    s1 = s1 + s5 + m[12] >>> 0;
    s13 = (s13 ^ s1) >>> 16 | (s13 ^ s1) << 16 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 12 | (s5 ^ s9) << 20 >>> 0;
    s1 = s1 + s5 + m[9] >>> 0;
    s13 = (s13 ^ s1) >>> 8 | (s13 ^ s1) << 24 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 7 | (s5 ^ s9) << 25 >>> 0;
    s2 = s2 + s6 + m[14] >>> 0;
    s14 = (s14 ^ s2) >>> 16 | (s14 ^ s2) << 16 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 12 | (s6 ^ s10) << 20 >>> 0;
    s2 = s2 + s6 + m[3] >>> 0;
    s14 = (s14 ^ s2) >>> 8 | (s14 ^ s2) << 24 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 7 | (s6 ^ s10) << 25 >>> 0;
    s3 = s3 + s7 + m[13] >>> 0;
    s15 = (s15 ^ s3) >>> 16 | (s15 ^ s3) << 16 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 12 | (s7 ^ s11) << 20 >>> 0;
    s3 = s3 + s7 + m[15] >>> 0;
    s15 = (s15 ^ s3) >>> 8 | (s15 ^ s3) << 24 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 7 | (s7 ^ s11) << 25 >>> 0;
    s0 = s0 + s5 + m[4] >>> 0;
    s15 = (s15 ^ s0) >>> 16 | (s15 ^ s0) << 16 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 12 | (s5 ^ s10) << 20 >>> 0;
    s0 = s0 + s5 + m[0] >>> 0;
    s15 = (s15 ^ s0) >>> 8 | (s15 ^ s0) << 24 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 7 | (s5 ^ s10) << 25 >>> 0;
    s1 = s1 + s6 + m[11] >>> 0;
    s12 = (s12 ^ s1) >>> 16 | (s12 ^ s1) << 16 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 12 | (s6 ^ s11) << 20 >>> 0;
    s1 = s1 + s6 + m[2] >>> 0;
    s12 = (s12 ^ s1) >>> 8 | (s12 ^ s1) << 24 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 7 | (s6 ^ s11) << 25 >>> 0;
    s2 = s2 + s7 + m[5] >>> 0;
    s13 = (s13 ^ s2) >>> 16 | (s13 ^ s2) << 16 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 12 | (s7 ^ s8) << 20 >>> 0;
    s2 = s2 + s7 + m[8] >>> 0;
    s13 = (s13 ^ s2) >>> 8 | (s13 ^ s2) << 24 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 7 | (s7 ^ s8) << 25 >>> 0;
    s3 = s3 + s4 + m[1] >>> 0;
    s14 = (s14 ^ s3) >>> 16 | (s14 ^ s3) << 16 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 12 | (s4 ^ s9) << 20 >>> 0;
    s3 = s3 + s4 + m[6] >>> 0;
    s14 = (s14 ^ s3) >>> 8 | (s14 ^ s3) << 24 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 7 | (s4 ^ s9) << 25 >>> 0;
    s0 = s0 + s4 + m[12] >>> 0;
    s12 = (s12 ^ s0) >>> 16 | (s12 ^ s0) << 16 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 12 | (s4 ^ s8) << 20 >>> 0;
    s0 = s0 + s4 + m[13] >>> 0;
    s12 = (s12 ^ s0) >>> 8 | (s12 ^ s0) << 24 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 7 | (s4 ^ s8) << 25 >>> 0;
    s1 = s1 + s5 + m[9] >>> 0;
    s13 = (s13 ^ s1) >>> 16 | (s13 ^ s1) << 16 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 12 | (s5 ^ s9) << 20 >>> 0;
    s1 = s1 + s5 + m[11] >>> 0;
    s13 = (s13 ^ s1) >>> 8 | (s13 ^ s1) << 24 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 7 | (s5 ^ s9) << 25 >>> 0;
    s2 = s2 + s6 + m[15] >>> 0;
    s14 = (s14 ^ s2) >>> 16 | (s14 ^ s2) << 16 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 12 | (s6 ^ s10) << 20 >>> 0;
    s2 = s2 + s6 + m[10] >>> 0;
    s14 = (s14 ^ s2) >>> 8 | (s14 ^ s2) << 24 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 7 | (s6 ^ s10) << 25 >>> 0;
    s3 = s3 + s7 + m[14] >>> 0;
    s15 = (s15 ^ s3) >>> 16 | (s15 ^ s3) << 16 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 12 | (s7 ^ s11) << 20 >>> 0;
    s3 = s3 + s7 + m[8] >>> 0;
    s15 = (s15 ^ s3) >>> 8 | (s15 ^ s3) << 24 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 7 | (s7 ^ s11) << 25 >>> 0;
    s0 = s0 + s5 + m[7] >>> 0;
    s15 = (s15 ^ s0) >>> 16 | (s15 ^ s0) << 16 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 12 | (s5 ^ s10) << 20 >>> 0;
    s0 = s0 + s5 + m[2] >>> 0;
    s15 = (s15 ^ s0) >>> 8 | (s15 ^ s0) << 24 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 7 | (s5 ^ s10) << 25 >>> 0;
    s1 = s1 + s6 + m[5] >>> 0;
    s12 = (s12 ^ s1) >>> 16 | (s12 ^ s1) << 16 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 12 | (s6 ^ s11) << 20 >>> 0;
    s1 = s1 + s6 + m[3] >>> 0;
    s12 = (s12 ^ s1) >>> 8 | (s12 ^ s1) << 24 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 7 | (s6 ^ s11) << 25 >>> 0;
    s2 = s2 + s7 + m[0] >>> 0;
    s13 = (s13 ^ s2) >>> 16 | (s13 ^ s2) << 16 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 12 | (s7 ^ s8) << 20 >>> 0;
    s2 = s2 + s7 + m[1] >>> 0;
    s13 = (s13 ^ s2) >>> 8 | (s13 ^ s2) << 24 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 7 | (s7 ^ s8) << 25 >>> 0;
    s3 = s3 + s4 + m[6] >>> 0;
    s14 = (s14 ^ s3) >>> 16 | (s14 ^ s3) << 16 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 12 | (s4 ^ s9) << 20 >>> 0;
    s3 = s3 + s4 + m[4] >>> 0;
    s14 = (s14 ^ s3) >>> 8 | (s14 ^ s3) << 24 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 7 | (s4 ^ s9) << 25 >>> 0;
    s0 = s0 + s4 + m[9] >>> 0;
    s12 = (s12 ^ s0) >>> 16 | (s12 ^ s0) << 16 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 12 | (s4 ^ s8) << 20 >>> 0;
    s0 = s0 + s4 + m[14] >>> 0;
    s12 = (s12 ^ s0) >>> 8 | (s12 ^ s0) << 24 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 7 | (s4 ^ s8) << 25 >>> 0;
    s1 = s1 + s5 + m[11] >>> 0;
    s13 = (s13 ^ s1) >>> 16 | (s13 ^ s1) << 16 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 12 | (s5 ^ s9) << 20 >>> 0;
    s1 = s1 + s5 + m[5] >>> 0;
    s13 = (s13 ^ s1) >>> 8 | (s13 ^ s1) << 24 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 7 | (s5 ^ s9) << 25 >>> 0;
    s2 = s2 + s6 + m[8] >>> 0;
    s14 = (s14 ^ s2) >>> 16 | (s14 ^ s2) << 16 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 12 | (s6 ^ s10) << 20 >>> 0;
    s2 = s2 + s6 + m[12] >>> 0;
    s14 = (s14 ^ s2) >>> 8 | (s14 ^ s2) << 24 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 7 | (s6 ^ s10) << 25 >>> 0;
    s3 = s3 + s7 + m[15] >>> 0;
    s15 = (s15 ^ s3) >>> 16 | (s15 ^ s3) << 16 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 12 | (s7 ^ s11) << 20 >>> 0;
    s3 = s3 + s7 + m[1] >>> 0;
    s15 = (s15 ^ s3) >>> 8 | (s15 ^ s3) << 24 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 7 | (s7 ^ s11) << 25 >>> 0;
    s0 = s0 + s5 + m[13] >>> 0;
    s15 = (s15 ^ s0) >>> 16 | (s15 ^ s0) << 16 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 12 | (s5 ^ s10) << 20 >>> 0;
    s0 = s0 + s5 + m[3] >>> 0;
    s15 = (s15 ^ s0) >>> 8 | (s15 ^ s0) << 24 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 7 | (s5 ^ s10) << 25 >>> 0;
    s1 = s1 + s6 + m[0] >>> 0;
    s12 = (s12 ^ s1) >>> 16 | (s12 ^ s1) << 16 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 12 | (s6 ^ s11) << 20 >>> 0;
    s1 = s1 + s6 + m[10] >>> 0;
    s12 = (s12 ^ s1) >>> 8 | (s12 ^ s1) << 24 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 7 | (s6 ^ s11) << 25 >>> 0;
    s2 = s2 + s7 + m[2] >>> 0;
    s13 = (s13 ^ s2) >>> 16 | (s13 ^ s2) << 16 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 12 | (s7 ^ s8) << 20 >>> 0;
    s2 = s2 + s7 + m[6] >>> 0;
    s13 = (s13 ^ s2) >>> 8 | (s13 ^ s2) << 24 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 7 | (s7 ^ s8) << 25 >>> 0;
    s3 = s3 + s4 + m[4] >>> 0;
    s14 = (s14 ^ s3) >>> 16 | (s14 ^ s3) << 16 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 12 | (s4 ^ s9) << 20 >>> 0;
    s3 = s3 + s4 + m[7] >>> 0;
    s14 = (s14 ^ s3) >>> 8 | (s14 ^ s3) << 24 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 7 | (s4 ^ s9) << 25 >>> 0;
    s0 = s0 + s4 + m[11] >>> 0;
    s12 = (s12 ^ s0) >>> 16 | (s12 ^ s0) << 16 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 12 | (s4 ^ s8) << 20 >>> 0;
    s0 = s0 + s4 + m[15] >>> 0;
    s12 = (s12 ^ s0) >>> 8 | (s12 ^ s0) << 24 >>> 0;
    s8 = s8 + s12 >>> 0;
    s4 = (s4 ^ s8) >>> 7 | (s4 ^ s8) << 25 >>> 0;
    s1 = s1 + s5 + m[5] >>> 0;
    s13 = (s13 ^ s1) >>> 16 | (s13 ^ s1) << 16 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 12 | (s5 ^ s9) << 20 >>> 0;
    s1 = s1 + s5 + m[0] >>> 0;
    s13 = (s13 ^ s1) >>> 8 | (s13 ^ s1) << 24 >>> 0;
    s9 = s9 + s13 >>> 0;
    s5 = (s5 ^ s9) >>> 7 | (s5 ^ s9) << 25 >>> 0;
    s2 = s2 + s6 + m[1] >>> 0;
    s14 = (s14 ^ s2) >>> 16 | (s14 ^ s2) << 16 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 12 | (s6 ^ s10) << 20 >>> 0;
    s2 = s2 + s6 + m[9] >>> 0;
    s14 = (s14 ^ s2) >>> 8 | (s14 ^ s2) << 24 >>> 0;
    s10 = s10 + s14 >>> 0;
    s6 = (s6 ^ s10) >>> 7 | (s6 ^ s10) << 25 >>> 0;
    s3 = s3 + s7 + m[8] >>> 0;
    s15 = (s15 ^ s3) >>> 16 | (s15 ^ s3) << 16 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 12 | (s7 ^ s11) << 20 >>> 0;
    s3 = s3 + s7 + m[6] >>> 0;
    s15 = (s15 ^ s3) >>> 8 | (s15 ^ s3) << 24 >>> 0;
    s11 = s11 + s15 >>> 0;
    s7 = (s7 ^ s11) >>> 7 | (s7 ^ s11) << 25 >>> 0;
    s0 = s0 + s5 + m[14] >>> 0;
    s15 = (s15 ^ s0) >>> 16 | (s15 ^ s0) << 16 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 12 | (s5 ^ s10) << 20 >>> 0;
    s0 = s0 + s5 + m[10] >>> 0;
    s15 = (s15 ^ s0) >>> 8 | (s15 ^ s0) << 24 >>> 0;
    s10 = s10 + s15 >>> 0;
    s5 = (s5 ^ s10) >>> 7 | (s5 ^ s10) << 25 >>> 0;
    s1 = s1 + s6 + m[2] >>> 0;
    s12 = (s12 ^ s1) >>> 16 | (s12 ^ s1) << 16 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 12 | (s6 ^ s11) << 20 >>> 0;
    s1 = s1 + s6 + m[12] >>> 0;
    s12 = (s12 ^ s1) >>> 8 | (s12 ^ s1) << 24 >>> 0;
    s11 = s11 + s12 >>> 0;
    s6 = (s6 ^ s11) >>> 7 | (s6 ^ s11) << 25 >>> 0;
    s2 = s2 + s7 + m[3] >>> 0;
    s13 = (s13 ^ s2) >>> 16 | (s13 ^ s2) << 16 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 12 | (s7 ^ s8) << 20 >>> 0;
    s2 = s2 + s7 + m[4] >>> 0;
    s13 = (s13 ^ s2) >>> 8 | (s13 ^ s2) << 24 >>> 0;
    s8 = s8 + s13 >>> 0;
    s7 = (s7 ^ s8) >>> 7 | (s7 ^ s8) << 25 >>> 0;
    s3 = s3 + s4 + m[7] >>> 0;
    s14 = (s14 ^ s3) >>> 16 | (s14 ^ s3) << 16 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 12 | (s4 ^ s9) << 20 >>> 0;
    s3 = s3 + s4 + m[13] >>> 0;
    s14 = (s14 ^ s3) >>> 8 | (s14 ^ s3) << 24 >>> 0;
    s9 = s9 + s14 >>> 0;
    s4 = (s4 ^ s9) >>> 7 | (s4 ^ s9) << 25 >>> 0;
    STATE[0] = s0 ^ s8;
    STATE[1] = s1 ^ s9;
    STATE[2] = s2 ^ s10;
    STATE[3] = s3 ^ s11;
    STATE[4] = s4 ^ s12;
    STATE[5] = s5 ^ s13;
    STATE[6] = s6 ^ s14;
    STATE[7] = s7 ^ s15;
    STATE[8] = s8 ^ cv[0];
    STATE[9] = s9 ^ cv[1];
    STATE[10] = s10 ^ cv[2];
    STATE[11] = s11 ^ cv[3];
    STATE[12] = s12 ^ cv[4];
    STATE[13] = s13 ^ cv[5];
    STATE[14] = s14 ^ cv[6];
    STATE[15] = s15 ^ cv[7];
    return STATE;
  }
  function chainingValue2(chunk, chunkCounter, flags) {
    CV_BUFFER.set(IV);
    let pos = 0;
    const numBlocks = Math.ceil(chunk.length / BLOCK_LEN) || 1;
    for (let i = 0; i < numBlocks; i++) {
      const blockStart = pos;
      const blockEnd = Math.min(pos + BLOCK_LEN, chunk.length);
      const blockLen = blockEnd - blockStart;
      const block = new Uint8Array(BLOCK_LEN);
      if (blockLen > 0) {
        block.set(chunk.subarray(blockStart, blockEnd));
      }
      let blockFlags = flags;
      if (i === 0)
        blockFlags |= CHUNK_START;
      if (i === numBlocks - 1)
        blockFlags |= CHUNK_END;
      const state = compress2(
        CV_BUFFER,
        block,
        chunkCounter,
        blockLen,
        blockFlags
      );
      CV_BUFFER[0] = state[0];
      CV_BUFFER[1] = state[1];
      CV_BUFFER[2] = state[2];
      CV_BUFFER[3] = state[3];
      CV_BUFFER[4] = state[4];
      CV_BUFFER[5] = state[5];
      CV_BUFFER[6] = state[6];
      CV_BUFFER[7] = state[7];
      pos += BLOCK_LEN;
    }
    return CV_BUFFER.slice();
  }
  function parentCv2(left, right, flags) {
    const view = new DataView(PARENT_BLOCK.buffer);
    for (let i = 0; i < 8; i++) {
      view.setUint32(i * 4, left[i], true);
      view.setUint32(32 + i * 4, right[i], true);
    }
    const state = compress2(IV, PARENT_BLOCK, 0n, BLOCK_LEN, flags | PARENT);
    return new Uint32Array([
      state[0],
      state[1],
      state[2],
      state[3],
      state[4],
      state[5],
      state[6],
      state[7]
    ]);
  }
  function wordsToOutput(state, length) {
    const output = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      output[i] = state[i >>> 2] >>> (i & 3) * 8 & 255;
    }
    return output;
  }
  function hash2(input, outputLength = OUT_LEN) {
    if (input.length === 0) {
      const block = new Uint8Array(BLOCK_LEN);
      const state = compress2(IV, block, 0n, 0, CHUNK_START | CHUNK_END | ROOT);
      return wordsToOutput(state, outputLength);
    }
    if (input.length <= CHUNK_LEN) {
      CV_BUFFER.set(IV);
      let pos2 = 0;
      const numBlocks = Math.ceil(input.length / BLOCK_LEN);
      for (let i = 0; i < numBlocks; i++) {
        const blockStart = pos2;
        const blockEnd = Math.min(pos2 + BLOCK_LEN, input.length);
        const blockLen = blockEnd - blockStart;
        const block = new Uint8Array(BLOCK_LEN);
        block.set(input.subarray(blockStart, blockEnd));
        let flags = 0;
        if (i === 0)
          flags |= CHUNK_START;
        if (i === numBlocks - 1)
          flags |= CHUNK_END | ROOT;
        const state = compress2(CV_BUFFER, block, 0n, blockLen, flags);
        if (flags & ROOT) {
          return wordsToOutput(state, outputLength);
        }
        CV_BUFFER[0] = state[0];
        CV_BUFFER[1] = state[1];
        CV_BUFFER[2] = state[2];
        CV_BUFFER[3] = state[3];
        CV_BUFFER[4] = state[4];
        CV_BUFFER[5] = state[5];
        CV_BUFFER[6] = state[6];
        CV_BUFFER[7] = state[7];
        pos2 += BLOCK_LEN;
      }
    }
    const cvStack = [];
    let chunkCounter = 0n;
    let pos = 0;
    const totalChunks = Math.ceil(input.length / CHUNK_LEN);
    while (pos + CHUNK_LEN <= input.length) {
      const chunk = input.subarray(pos, pos + CHUNK_LEN);
      const cv = chainingValue2(chunk, chunkCounter, 0);
      cvStack.push(cv);
      chunkCounter++;
      let mergeCount = ctz64(chunkCounter);
      while (mergeCount > 0 && cvStack.length > 1) {
        if (chunkCounter === BigInt(totalChunks) && cvStack.length === 2) {
          break;
        }
        const right = cvStack.pop();
        const left = cvStack.pop();
        cvStack.push(parentCv2(left, right, 0));
        mergeCount--;
      }
      pos += CHUNK_LEN;
    }
    if (pos < input.length) {
      const chunk = input.subarray(pos);
      const cv = chainingValue2(chunk, chunkCounter, 0);
      cvStack.push(cv);
    }
    while (cvStack.length > 2) {
      const right = cvStack.pop();
      const left = cvStack.pop();
      cvStack.push(parentCv2(left, right, 0));
    }
    if (cvStack.length === 2) {
      const right = cvStack.pop();
      const left = cvStack.pop();
      const view = new DataView(PARENT_BLOCK.buffer);
      for (let i = 0; i < 8; i++) {
        view.setUint32(i * 4, left[i], true);
        view.setUint32(32 + i * 4, right[i], true);
      }
      const state = compress2(IV, PARENT_BLOCK, 0n, BLOCK_LEN, PARENT | ROOT);
      return wordsToOutput(state, outputLength);
    }
    throw new Error("Unexpected state in multi-chunk hash");
  }

  // src/simd.ts
  var SIMD_SUPPORTED = (() => {
    if (typeof WebAssembly === "undefined")
      return false;
    try {
      return WebAssembly.validate(
        new Uint8Array([
          0,
          97,
          115,
          109,
          // Magic: \0asm
          1,
          0,
          0,
          0,
          // Version: 1
          1,
          5,
          1,
          96,
          0,
          1,
          123,
          // Type: () -> v128
          3,
          2,
          1,
          0,
          // Func: index 0
          10,
          22,
          1,
          20,
          0,
          // Code section
          253,
          12,
          // v128.const
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          11
          // end
        ])
      );
    } catch {
      return false;
    }
  })();
  var WasmBuilder = class {
    constructor() {
      this.bytes = [];
    }
    put(...data) {
      this.bytes.push(...data);
    }
    // LEB128 encoding for unsigned integers
    putULEB128(value) {
      do {
        let byte = value & 127;
        value >>>= 7;
        if (value !== 0)
          byte |= 128;
        this.bytes.push(byte);
      } while (value !== 0);
    }
    // Section with size prefix
    section(id, content) {
      this.bytes.push(id);
      this.putULEB128(content.length);
      this.bytes.push(...content);
    }
    build() {
      return new Uint8Array(this.bytes);
    }
  };
  function generateCompress4xModule() {
    const code = [];
    const M_ACCESS_ORDER = [];
    for (let round2 = 0; round2 < 7; round2++) {
      const schedule = MSG_SCHEDULE[round2];
      for (let g3 = 0; g3 < 8; g3++) {
        M_ACCESS_ORDER.push(schedule[g3 * 2], schedule[g3 * 2 + 1]);
      }
    }
    let mIndex = 0;
    function gi(a, b, c, d, rotD, rotB) {
      const m = M_ACCESS_ORDER[mIndex++];
      code.push(32, a);
      code.push(32, m);
      code.push(253, 174, 1);
      code.push(32, b);
      code.push(253, 174, 1);
      code.push(34, a);
      code.push(32, d);
      code.push(253, 81);
      code.push(34, d);
      code.push(65, rotD);
      code.push(253, 173, 1);
      code.push(32, d);
      code.push(65, 32 - rotD);
      code.push(253, 171, 1);
      code.push(253, 80);
      code.push(34, d);
      code.push(32, c);
      code.push(253, 174, 1);
      code.push(34, c);
      code.push(32, b);
      code.push(253, 81);
      code.push(34, b);
      code.push(65, rotB);
      code.push(253, 173, 1);
      code.push(32, b);
      code.push(65, 32 - rotB);
      code.push(253, 171, 1);
      code.push(253, 80);
    }
    function g2(a, b, c, d) {
      gi(a, b, c, d, 16, 12);
      code.push(34, b);
      gi(a, b, c, d, 8, 7);
      code.push(33, b);
    }
    const S = (i) => 16 + i;
    for (let i = 0; i < 16; i++) {
      code.push(65, 0);
      code.push(253, 0);
      code.push(i * 16);
      code.push(0);
      code.push(33, i);
    }
    for (let i = 0; i < 8; i++) {
      code.push(65, 0);
      code.push(253, 0);
      code.push(128, 2 + i * 16);
      code.push(0);
      code.push(33, S(i));
    }
    for (let i = 0; i < 4; i++) {
      const iv = IV[i];
      code.push(253, 12);
      for (let lane = 0; lane < 4; lane++) {
        code.push(
          iv & 255,
          iv >> 8 & 255,
          iv >> 16 & 255,
          iv >> 24 & 255
        );
      }
      code.push(33, S(8 + i));
    }
    code.push(32, 40);
    code.push(253, 17);
    code.push(33, S(12));
    code.push(32, 41);
    code.push(253, 17);
    code.push(33, S(13));
    code.push(32, 42);
    code.push(253, 17);
    code.push(33, S(14));
    code.push(32, 43);
    code.push(253, 17);
    code.push(33, S(15));
    for (let round2 = 0; round2 < 7; round2++) {
      g2(S(0), S(4), S(8), S(12));
      g2(S(1), S(5), S(9), S(13));
      g2(S(2), S(6), S(10), S(14));
      g2(S(3), S(7), S(11), S(15));
      g2(S(0), S(5), S(10), S(15));
      g2(S(1), S(6), S(11), S(12));
      g2(S(2), S(7), S(8), S(13));
      g2(S(3), S(4), S(9), S(14));
    }
    for (let i = 0; i < 8; i++) {
      code.push(65, 0);
      code.push(32, S(i));
      code.push(32, S(i + 8));
      code.push(253, 81);
      code.push(253, 11);
      code.push(128, 4 + i * 16);
      code.push(0);
    }
    code.push(11);
    const builder = new WasmBuilder();
    builder.put(0, 97, 115, 109);
    builder.put(1, 0, 0, 0);
    builder.section(1, [
      1,
      // 1 type
      96,
      // func type
      4,
      127,
      127,
      127,
      127,
      // 4 params: i32 × 4
      0
      // 0 results
    ]);
    builder.section(3, [1, 0]);
    builder.section(5, [1, 0, 1]);
    const exportName = [8, ...Array.from("compress", (c) => c.charCodeAt(0))];
    const memName = [3, ...Array.from("mem", (c) => c.charCodeAt(0))];
    builder.section(7, [
      2,
      // 2 exports
      ...exportName,
      0,
      0,
      // "compress" -> func 0
      ...memName,
      2,
      0
      // "mem" -> memory 0
    ]);
    const locals = [
      1,
      // 1 local group
      40,
      123
      // 40 locals of type v128
    ];
    const bodyLen = locals.length + code.length;
    const codeSectionContent = [1];
    let size = bodyLen;
    do {
      let byte = size & 127;
      size >>>= 7;
      if (size !== 0)
        byte |= 128;
      codeSectionContent.push(byte);
    } while (size !== 0);
    codeSectionContent.push(...locals, ...code);
    builder.section(10, codeSectionContent);
    return builder.build();
  }
  var wasmInstance = null;
  var wasmMemory = null;
  var compress4xFn = null;
  function initWasm() {
    if (wasmInstance)
      return true;
    if (!SIMD_SUPPORTED)
      return false;
    try {
      const wasmBytes = generateCompress4xModule();
      const buffer = new ArrayBuffer(wasmBytes.length);
      new Uint8Array(buffer).set(wasmBytes);
      const module = new WebAssembly.Module(buffer);
      wasmInstance = new WebAssembly.Instance(module);
      wasmMemory = wasmInstance.exports.mem;
      compress4xFn = wasmInstance.exports.compress;
      return true;
    } catch {
      return false;
    }
  }
  function compress4xChunks(chunks, chunkCounter, cv) {
    if (!wasmMemory || !compress4xFn) {
      throw new Error("WASM not initialized");
    }
    const mem3 = new Uint8Array(wasmMemory.buffer);
    const memView = new DataView(wasmMemory.buffer);
    for (let block = 0; block < 16; block++) {
      for (let word = 0; word < 16; word++) {
        const offset = (block * 16 + word) * 16;
        for (let chunk = 0; chunk < 4; chunk++) {
          const chunkOffset = block * BLOCK_LEN + word * 4;
          const value = chunks[chunk].length > chunkOffset + 3 ? (chunks[chunk][chunkOffset] | chunks[chunk][chunkOffset + 1] << 8 | chunks[chunk][chunkOffset + 2] << 16 | chunks[chunk][chunkOffset + 3] << 24) >>> 0 : 0;
          memView.setUint32(offset + chunk * 4, value, true);
        }
      }
    }
    for (let i = 0; i < 8; i++) {
      for (let lane = 0; lane < 4; lane++) {
        memView.setUint32(256 + i * 16 + lane * 4, cv[i], true);
      }
    }
    const results = [
      new Uint32Array(8),
      new Uint32Array(8),
      new Uint32Array(8),
      new Uint32Array(8)
    ];
    const currentCvs = [cv.slice(), cv.slice(), cv.slice(), cv.slice()];
    for (let block = 0; block < 16; block++) {
      let flags = 0;
      if (block === 0)
        flags |= CHUNK_START;
      if (block === 15)
        flags |= CHUNK_END;
      compress4xFn(
        Number(chunkCounter & 0xffffffffn),
        Number(chunkCounter >> 32n & 0xffffffffn),
        BLOCK_LEN,
        flags
      );
      for (let i = 0; i < 8; i++) {
        for (let lane = 0; lane < 4; lane++) {
          const value = memView.getUint32(512 + i * 16 + lane * 4, true);
          if (block === 15) {
            results[lane][i] = value;
          } else {
            currentCvs[lane][i] = value;
            memView.setUint32(256 + i * 16 + lane * 4, value, true);
          }
        }
      }
    }
    return results;
  }
  var CV_BUFFER2 = new Uint32Array(8);
  var PARENT_BLOCK2 = new Uint8Array(64);
  function chainingValue3(chunk, chunkCounter, flags) {
    CV_BUFFER2.set(IV);
    let pos = 0;
    const numBlocks = Math.ceil(chunk.length / BLOCK_LEN) || 1;
    for (let i = 0; i < numBlocks; i++) {
      const blockStart = pos;
      const blockEnd = Math.min(pos + BLOCK_LEN, chunk.length);
      const blockLen = blockEnd - blockStart;
      const block = new Uint8Array(BLOCK_LEN);
      if (blockLen > 0) {
        block.set(chunk.subarray(blockStart, blockEnd));
      }
      let blockFlags = flags;
      if (i === 0)
        blockFlags |= CHUNK_START;
      if (i === numBlocks - 1)
        blockFlags |= CHUNK_END;
      const state = compress2(
        CV_BUFFER2,
        block,
        chunkCounter,
        blockLen,
        blockFlags
      );
      for (let j = 0; j < 8; j++)
        CV_BUFFER2[j] = state[j];
      pos += BLOCK_LEN;
    }
    return CV_BUFFER2.slice();
  }
  function parentCv3(left, right, flags) {
    const view = new DataView(PARENT_BLOCK2.buffer);
    for (let i = 0; i < 8; i++) {
      view.setUint32(i * 4, left[i], true);
      view.setUint32(32 + i * 4, right[i], true);
    }
    const state = compress2(IV, PARENT_BLOCK2, 0n, BLOCK_LEN, flags | PARENT);
    return new Uint32Array([
      state[0],
      state[1],
      state[2],
      state[3],
      state[4],
      state[5],
      state[6],
      state[7]
    ]);
  }
  function wordsToOutput2(state, length) {
    const output = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      output[i] = state[i >>> 2] >>> (i & 3) * 8 & 255;
    }
    return output;
  }
  function hash3(input, outputLength = OUT_LEN) {
    const simdAvailable = initWasm();
    if (input.length === 0) {
      const block = new Uint8Array(BLOCK_LEN);
      const state = compress2(IV, block, 0n, 0, CHUNK_START | CHUNK_END | ROOT);
      return wordsToOutput2(state, outputLength);
    }
    if (input.length <= CHUNK_LEN) {
      CV_BUFFER2.set(IV);
      let pos2 = 0;
      const numBlocks = Math.ceil(input.length / BLOCK_LEN);
      for (let i = 0; i < numBlocks; i++) {
        const blockStart = pos2;
        const blockEnd = Math.min(pos2 + BLOCK_LEN, input.length);
        const blockLen = blockEnd - blockStart;
        const block = new Uint8Array(BLOCK_LEN);
        block.set(input.subarray(blockStart, blockEnd));
        let flags = 0;
        if (i === 0)
          flags |= CHUNK_START;
        if (i === numBlocks - 1)
          flags |= CHUNK_END | ROOT;
        const state = compress2(CV_BUFFER2, block, 0n, blockLen, flags);
        if (flags & ROOT) {
          return wordsToOutput2(state, outputLength);
        }
        for (let j = 0; j < 8; j++)
          CV_BUFFER2[j] = state[j];
        pos2 += BLOCK_LEN;
      }
    }
    const cvStack = [];
    let chunkCounter = 0n;
    let pos = 0;
    const totalChunks = Math.ceil(input.length / CHUNK_LEN);
    if (simdAvailable && input.length >= CHUNK_LEN * 4) {
      while (pos + CHUNK_LEN * 4 <= input.length) {
        const chunks = [
          input.subarray(pos, pos + CHUNK_LEN),
          input.subarray(pos + CHUNK_LEN, pos + CHUNK_LEN * 2),
          input.subarray(pos + CHUNK_LEN * 2, pos + CHUNK_LEN * 3),
          input.subarray(pos + CHUNK_LEN * 3, pos + CHUNK_LEN * 4)
        ];
        const cvs = compress4xChunks(chunks, chunkCounter, IV);
        for (let i = 0; i < 4; i++) {
          cvStack.push(cvs[i]);
          chunkCounter++;
          let mergeCount = ctz64(chunkCounter);
          while (mergeCount > 0 && cvStack.length > 1) {
            if (chunkCounter === BigInt(totalChunks) && cvStack.length === 2) {
              break;
            }
            const right = cvStack.pop();
            const left = cvStack.pop();
            cvStack.push(parentCv3(left, right, 0));
            mergeCount--;
          }
        }
        pos += CHUNK_LEN * 4;
      }
    }
    while (pos + CHUNK_LEN <= input.length) {
      const chunk = input.subarray(pos, pos + CHUNK_LEN);
      const cv = chainingValue3(chunk, chunkCounter, 0);
      cvStack.push(cv);
      chunkCounter++;
      let mergeCount = ctz64(chunkCounter);
      while (mergeCount > 0 && cvStack.length > 1) {
        if (chunkCounter === BigInt(totalChunks) && cvStack.length === 2) {
          break;
        }
        const right = cvStack.pop();
        const left = cvStack.pop();
        cvStack.push(parentCv3(left, right, 0));
        mergeCount--;
      }
      pos += CHUNK_LEN;
    }
    if (pos < input.length) {
      const chunk = input.subarray(pos);
      const cv = chainingValue3(chunk, chunkCounter, 0);
      cvStack.push(cv);
    }
    while (cvStack.length > 2) {
      const right = cvStack.pop();
      const left = cvStack.pop();
      cvStack.push(parentCv3(left, right, 0));
    }
    if (cvStack.length === 2) {
      const right = cvStack.pop();
      const left = cvStack.pop();
      const view = new DataView(PARENT_BLOCK2.buffer);
      for (let i = 0; i < 8; i++) {
        view.setUint32(i * 4, left[i], true);
        view.setUint32(32 + i * 4, right[i], true);
      }
      const state = compress2(IV, PARENT_BLOCK2, 0n, BLOCK_LEN, PARENT | ROOT);
      return wordsToOutput2(state, outputLength);
    }
    throw new Error("Unexpected state in multi-chunk hash");
  }

  // src/simd-fast.ts
  var SIMD_SUPPORTED2 = (() => {
    if (typeof WebAssembly === "undefined")
      return false;
    try {
      return WebAssembly.validate(
        new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          5,
          1,
          96,
          0,
          1,
          123,
          3,
          2,
          1,
          0,
          10,
          22,
          1,
          20,
          0,
          253,
          12,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          11
        ])
      );
    } catch {
      return false;
    }
  })();
  var SCHED = [
    [
      [0, 2, 4, 6],
      [1, 3, 5, 7],
      [8, 10, 12, 14],
      [9, 11, 13, 15]
    ],
    [
      [2, 3, 7, 4],
      [6, 10, 0, 13],
      [1, 12, 9, 15],
      [11, 5, 14, 8]
    ],
    [
      [3, 10, 13, 7],
      [4, 12, 2, 14],
      [6, 9, 11, 8],
      [5, 0, 15, 1]
    ],
    [
      [10, 12, 14, 13],
      [7, 9, 3, 15],
      [4, 11, 5, 1],
      [0, 2, 8, 6]
    ],
    [
      [12, 9, 15, 14],
      [13, 11, 10, 8],
      [7, 5, 0, 6],
      [2, 3, 1, 4]
    ],
    [
      [9, 11, 8, 15],
      [14, 5, 12, 1],
      [13, 0, 2, 4],
      [3, 10, 6, 7]
    ],
    [
      [11, 5, 1, 8],
      [15, 0, 9, 6],
      [14, 2, 3, 7],
      [10, 12, 4, 13]
    ]
  ];
  var ROT1_L = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3];
  var ROT2_L = [8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7];
  var ROT3_L = [12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  var ROT1_R = [12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  var ROT2_R = [8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7];
  var ROT3_R = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3];
  var ROTR16 = [2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13];
  var ROTR8 = [1, 2, 3, 0, 5, 6, 7, 4, 9, 10, 11, 8, 13, 14, 15, 12];
  var OFF_INPUT = 0;
  var OFF_META = 1024;
  var OFF_PARENT = 1056;
  var OFF_OUTPUT = 1120;
  var WasmBuilder2 = class {
    constructor() {
      this.code = [];
    }
    emit(...b) {
      this.code.push(...b);
    }
    localGet(i) {
      this.emit(32, i);
    }
    localSet(i) {
      this.emit(33, i);
    }
    localTee(i) {
      this.emit(34, i);
    }
    // i32.const with LEB128 signed encoding
    i32Const(v) {
      this.emit(65);
      let val = v, more = true;
      while (more) {
        let b = val & 127;
        val >>= 7;
        more = !(val === 0 && !(b & 64) || val === -1 && b & 64);
        if (more)
          b |= 128;
        this.emit(b);
      }
    }
    i32Add() {
      this.emit(106);
    }
    i32Sub() {
      this.emit(107);
    }
    i32Mul() {
      this.emit(108);
    }
    i32DivU() {
      this.emit(109);
    }
    i32And() {
      this.emit(113);
    }
    i32Or() {
      this.emit(114);
    }
    i32Eq() {
      this.emit(70);
    }
    i32LtU() {
      this.emit(73);
    }
    i32Load(off) {
      this.emit(40, 2);
      this.uleb(off);
    }
    i32Store(off) {
      this.emit(54, 2);
      this.uleb(off);
    }
    // v128.const - embed 4 i32 values directly in the bytecode
    v128Const(a, b, c, d) {
      this.emit(253, 12);
      for (const v of [a, b, c, d])
        this.emit(v & 255, v >> 8 & 255, v >> 16 & 255, v >> 24 & 255);
    }
    v128Load(off) {
      this.emit(253, 0, 4);
      this.uleb(off);
    }
    v128Store(off) {
      this.emit(253, 11, 4);
      this.uleb(off);
    }
    v128Xor() {
      this.emit(253, 81);
    }
    v128Or() {
      this.emit(253, 80);
    }
    i32x4Add() {
      this.emit(253, 174, 1);
    }
    i32x4Shl() {
      this.emit(253, 171, 1);
    }
    i32x4ShrU() {
      this.emit(253, 173, 1);
    }
    i8x16Shuffle(idx) {
      this.emit(253, 13, ...idx);
    }
    i32x4Splat() {
      this.emit(253, 17);
    }
    i32x4ReplaceLane(l) {
      this.emit(253, 28, l);
    }
    block(code) {
      this.emit(2, 64);
      code();
      this.emit(11);
    }
    loop(code) {
      this.emit(3, 64);
      code();
      this.emit(11);
    }
    br(d) {
      this.emit(12, d);
    }
    brIf(d) {
      this.emit(13, d);
    }
    ifThen(code) {
      this.emit(4, 64);
      code();
      this.emit(11);
    }
    ifElse(thenCode, elseCode) {
      this.emit(4, 64);
      thenCode();
      this.emit(5);
      elseCode();
      this.emit(11);
    }
    end() {
      this.emit(11);
    }
    // Unsigned LEB128 encoding for offsets
    uleb(v) {
      do {
        let b = v & 127;
        v >>>= 7;
        if (v)
          b |= 128;
        this.emit(b);
      } while (v);
    }
  };
  function emitCompressBlock(w, getMsgPtr, ROW0, ROW1, ROW2, ROW3, MX, MY) {
    const gatherMsg = (i0, i1, i2, i3, dst) => {
      getMsgPtr();
      w.i32Load(i0 * 4);
      w.i32x4Splat();
      getMsgPtr();
      w.i32Load(i1 * 4);
      w.i32x4ReplaceLane(1);
      getMsgPtr();
      w.i32Load(i2 * 4);
      w.i32x4ReplaceLane(2);
      getMsgPtr();
      w.i32Load(i3 * 4);
      w.i32x4ReplaceLane(3);
      w.localSet(dst);
    };
    const gHalf = (mLoc, rot1, rot2) => {
      w.localGet(ROW0);
      w.localGet(ROW1);
      w.i32x4Add();
      w.localGet(mLoc);
      w.i32x4Add();
      w.localSet(ROW0);
      w.localGet(ROW3);
      w.localGet(ROW0);
      w.v128Xor();
      if (rot1 === 16) {
        w.localTee(ROW3);
        w.localGet(ROW3);
        w.i8x16Shuffle(ROTR16);
      } else {
        w.localTee(ROW3);
        w.localGet(ROW3);
        w.i8x16Shuffle(ROTR8);
      }
      w.localSet(ROW3);
      w.localGet(ROW2);
      w.localGet(ROW3);
      w.i32x4Add();
      w.localSet(ROW2);
      w.localGet(ROW1);
      w.localGet(ROW2);
      w.v128Xor();
      w.localTee(ROW1);
      w.i32Const(rot2);
      w.i32x4ShrU();
      w.localGet(ROW1);
      w.i32Const(32 - rot2);
      w.i32x4Shl();
      w.v128Or();
      w.localSet(ROW1);
    };
    const rotateDiag = () => {
      w.localGet(ROW1);
      w.localGet(ROW1);
      w.i8x16Shuffle(ROT1_L);
      w.localSet(ROW1);
      w.localGet(ROW2);
      w.localGet(ROW2);
      w.i8x16Shuffle(ROT2_L);
      w.localSet(ROW2);
      w.localGet(ROW3);
      w.localGet(ROW3);
      w.i8x16Shuffle(ROT3_L);
      w.localSet(ROW3);
    };
    const unrotateDiag = () => {
      w.localGet(ROW1);
      w.localGet(ROW1);
      w.i8x16Shuffle(ROT1_R);
      w.localSet(ROW1);
      w.localGet(ROW2);
      w.localGet(ROW2);
      w.i8x16Shuffle(ROT2_R);
      w.localSet(ROW2);
      w.localGet(ROW3);
      w.localGet(ROW3);
      w.i8x16Shuffle(ROT3_R);
      w.localSet(ROW3);
    };
    for (let r = 0; r < 7; r++) {
      const [colMx, colMy, diagMx, diagMy] = SCHED[r];
      gatherMsg(colMx[0], colMx[1], colMx[2], colMx[3], MX);
      gatherMsg(colMy[0], colMy[1], colMy[2], colMy[3], MY);
      gHalf(MX, 16, 12);
      gHalf(MY, 8, 7);
      rotateDiag();
      gatherMsg(diagMx[0], diagMx[1], diagMx[2], diagMx[3], MX);
      gatherMsg(diagMy[0], diagMy[1], diagMy[2], diagMy[3], MY);
      gHalf(MX, 16, 12);
      gHalf(MY, 8, 7);
      unrotateDiag();
    }
    w.localGet(ROW0);
    w.localGet(ROW2);
    w.v128Xor();
    w.localSet(ROW0);
    w.localGet(ROW1);
    w.localGet(ROW3);
    w.v128Xor();
    w.localSet(ROW1);
  }
  function buildCompressChunk() {
    const w = new WasmBuilder2();
    const ROW0 = 0, ROW1 = 1, ROW2 = 2, ROW3 = 3, MX = 4, MY = 5;
    const CV0 = 6, CV1 = 7;
    const BLOCK_IDX = 8, MSG_PTR = 9, FLAGS = 10;
    w.v128Const(IV[0], IV[1], IV[2], IV[3]);
    w.localSet(CV0);
    w.v128Const(IV[4], IV[5], IV[6], IV[7]);
    w.localSet(CV1);
    w.i32Const(0);
    w.localSet(BLOCK_IDX);
    w.i32Const(0);
    w.localSet(MSG_PTR);
    w.block(() => {
      w.loop(() => {
        w.localGet(CV0);
        w.localSet(ROW0);
        w.localGet(CV1);
        w.localSet(ROW1);
        w.v128Const(IV[0], IV[1], IV[2], IV[3]);
        w.localSet(ROW2);
        w.i32Const(0);
        w.localSet(FLAGS);
        w.localGet(BLOCK_IDX);
        w.i32Const(0);
        w.i32Eq();
        w.ifThen(() => {
          w.localGet(FLAGS);
          w.i32Const(CHUNK_START);
          w.i32Or();
          w.localSet(FLAGS);
        });
        w.localGet(BLOCK_IDX);
        w.i32Const(15);
        w.i32Eq();
        w.ifThen(() => {
          w.localGet(FLAGS);
          w.i32Const(CHUNK_END);
          w.i32Or();
          w.i32Const(OFF_META);
          w.i32Load(12);
          w.i32Or();
          w.localSet(FLAGS);
        });
        w.i32Const(OFF_META);
        w.i32Load(0);
        w.i32x4Splat();
        w.i32Const(OFF_META);
        w.i32Load(4);
        w.i32x4ReplaceLane(1);
        w.i32Const(64);
        w.i32x4ReplaceLane(2);
        w.localGet(FLAGS);
        w.i32x4ReplaceLane(3);
        w.localSet(ROW3);
        emitCompressBlock(
          w,
          () => w.localGet(MSG_PTR),
          ROW0,
          ROW1,
          ROW2,
          ROW3,
          MX,
          MY
        );
        w.localGet(ROW0);
        w.localSet(CV0);
        w.localGet(ROW1);
        w.localSet(CV1);
        w.localGet(BLOCK_IDX);
        w.i32Const(1);
        w.i32Add();
        w.localSet(BLOCK_IDX);
        w.localGet(MSG_PTR);
        w.i32Const(64);
        w.i32Add();
        w.localSet(MSG_PTR);
        w.localGet(BLOCK_IDX);
        w.i32Const(16);
        w.i32LtU();
        w.brIf(0);
      });
    });
    w.i32Const(OFF_OUTPUT);
    w.localGet(CV0);
    w.v128Store(0);
    w.i32Const(OFF_OUTPUT);
    w.localGet(CV1);
    w.v128Store(16);
    w.end();
    return w.code;
  }
  function buildCompressPartial() {
    const w = new WasmBuilder2();
    const ROW0 = 0, ROW1 = 1, ROW2 = 2, ROW3 = 3, MX = 4, MY = 5;
    const CV0 = 6, CV1 = 7;
    const BLOCK_IDX = 8, MSG_PTR = 9, FLAGS = 10;
    const CHUNK_LEN_L = 11, NUM_BLOCKS = 12, BLOCK_LEN_L = 13;
    w.i32Const(OFF_META);
    w.i32Load(8);
    w.localTee(CHUNK_LEN_L);
    w.i32Const(63);
    w.i32Add();
    w.i32Const(64);
    w.i32DivU();
    w.localSet(NUM_BLOCKS);
    w.localGet(NUM_BLOCKS);
    w.i32Const(0);
    w.i32Eq();
    w.ifThen(() => {
      w.i32Const(1);
      w.localSet(NUM_BLOCKS);
    });
    w.v128Const(IV[0], IV[1], IV[2], IV[3]);
    w.localSet(CV0);
    w.v128Const(IV[4], IV[5], IV[6], IV[7]);
    w.localSet(CV1);
    w.i32Const(0);
    w.localSet(BLOCK_IDX);
    w.i32Const(0);
    w.localSet(MSG_PTR);
    w.block(() => {
      w.loop(() => {
        w.localGet(CV0);
        w.localSet(ROW0);
        w.localGet(CV1);
        w.localSet(ROW1);
        w.v128Const(IV[0], IV[1], IV[2], IV[3]);
        w.localSet(ROW2);
        w.localGet(CHUNK_LEN_L);
        w.localGet(BLOCK_IDX);
        w.i32Const(64);
        w.i32Mul();
        w.i32Sub();
        w.localTee(BLOCK_LEN_L);
        w.i32Const(64);
        w.i32LtU();
        w.ifElse(
          () => {
          },
          () => {
            w.i32Const(64);
            w.localSet(BLOCK_LEN_L);
          }
        );
        w.i32Const(0);
        w.localSet(FLAGS);
        w.localGet(BLOCK_IDX);
        w.i32Const(0);
        w.i32Eq();
        w.ifThen(() => {
          w.localGet(FLAGS);
          w.i32Const(CHUNK_START);
          w.i32Or();
          w.localSet(FLAGS);
        });
        w.localGet(BLOCK_IDX);
        w.i32Const(1);
        w.i32Add();
        w.localGet(NUM_BLOCKS);
        w.i32Eq();
        w.ifThen(() => {
          w.localGet(FLAGS);
          w.i32Const(CHUNK_END);
          w.i32Or();
          w.i32Const(OFF_META);
          w.i32Load(12);
          w.i32Or();
          w.localSet(FLAGS);
        });
        w.i32Const(OFF_META);
        w.i32Load(0);
        w.i32x4Splat();
        w.i32Const(OFF_META);
        w.i32Load(4);
        w.i32x4ReplaceLane(1);
        w.localGet(BLOCK_LEN_L);
        w.i32x4ReplaceLane(2);
        w.localGet(FLAGS);
        w.i32x4ReplaceLane(3);
        w.localSet(ROW3);
        emitCompressBlock(
          w,
          () => w.localGet(MSG_PTR),
          ROW0,
          ROW1,
          ROW2,
          ROW3,
          MX,
          MY
        );
        w.localGet(ROW0);
        w.localSet(CV0);
        w.localGet(ROW1);
        w.localSet(CV1);
        w.localGet(BLOCK_IDX);
        w.i32Const(1);
        w.i32Add();
        w.localSet(BLOCK_IDX);
        w.localGet(MSG_PTR);
        w.i32Const(64);
        w.i32Add();
        w.localSet(MSG_PTR);
        w.localGet(BLOCK_IDX);
        w.localGet(NUM_BLOCKS);
        w.i32LtU();
        w.brIf(0);
      });
    });
    w.i32Const(OFF_OUTPUT);
    w.localGet(CV0);
    w.v128Store(0);
    w.i32Const(OFF_OUTPUT);
    w.localGet(CV1);
    w.v128Store(16);
    w.end();
    return w.code;
  }
  function buildCompressParent() {
    const w = new WasmBuilder2();
    const ROW0 = 0, ROW1 = 1, ROW2 = 2, ROW3 = 3, MX = 4, MY = 5;
    w.v128Const(IV[0], IV[1], IV[2], IV[3]);
    w.localSet(ROW0);
    w.v128Const(IV[4], IV[5], IV[6], IV[7]);
    w.localSet(ROW1);
    w.v128Const(IV[0], IV[1], IV[2], IV[3]);
    w.localSet(ROW2);
    w.i32Const(0);
    w.i32x4Splat();
    w.i32Const(64);
    w.i32x4ReplaceLane(2);
    w.i32Const(OFF_META);
    w.i32Load(8);
    w.i32Const(PARENT);
    w.i32Or();
    w.i32x4ReplaceLane(3);
    w.localSet(ROW3);
    emitCompressBlock(
      w,
      () => w.i32Const(OFF_PARENT),
      ROW0,
      ROW1,
      ROW2,
      ROW3,
      MX,
      MY
    );
    w.i32Const(OFF_OUTPUT);
    w.localGet(ROW0);
    w.v128Store(0);
    w.i32Const(OFF_OUTPUT);
    w.localGet(ROW1);
    w.v128Store(16);
    w.end();
    return w.code;
  }
  function generateModule() {
    const mod = [];
    const put = (...b) => mod.push(...b);
    const uleb = (v) => {
      do {
        let b = v & 127;
        v >>>= 7;
        if (v)
          b |= 128;
        mod.push(b);
      } while (v);
    };
    const section = (id, data) => {
      mod.push(id);
      uleb(data.length);
      mod.push(...data);
    };
    put(0, 97, 115, 109, 1, 0, 0, 0);
    section(1, [1, 96, 0, 0]);
    section(3, [3, 0, 0, 0]);
    section(5, [1, 0, 1]);
    const exports = [4];
    const addExp = (name, kind, idx) => {
      exports.push(
        name.length,
        ...Array.from(name).map((c) => c.charCodeAt(0)),
        kind,
        idx
      );
    };
    addExp("compressChunk", 0, 0);
    addExp("compressPartial", 0, 1);
    addExp("compressParent", 0, 2);
    addExp("mem", 2, 0);
    section(7, exports);
    const chunkCode = buildCompressChunk();
    const partialCode = buildCompressPartial();
    const parentCode = buildCompressParent();
    const encodeFunc = (code, numV128, numI32) => {
      const locals = [];
      let groups = 0;
      if (numV128 > 0) {
        locals.push(numV128, 123);
        groups++;
      }
      if (numI32 > 0) {
        locals.push(numI32, 127);
        groups++;
      }
      const body = [groups, ...locals, ...code];
      const lenBytes = [];
      let len = body.length;
      do {
        let b = len & 127;
        len >>>= 7;
        if (len)
          b |= 128;
        lenBytes.push(b);
      } while (len);
      return [...lenBytes, ...body];
    };
    const func0 = encodeFunc(chunkCode, 8, 3);
    const func1 = encodeFunc(partialCode, 8, 6);
    const func2 = encodeFunc(parentCode, 6, 0);
    section(10, [3, ...func0, ...func1, ...func2]);
    return new Uint8Array(mod);
  }
  var instance = null;
  var compressChunkFn = null;
  var compressPartialFn = null;
  var compressParentFn = null;
  var mem = null;
  var mem32 = null;
  function initWasm2() {
    if (instance)
      return true;
    if (!SIMD_SUPPORTED2)
      return false;
    try {
      const module = new WebAssembly.Module(generateModule());
      instance = new WebAssembly.Instance(module);
      const wasmMem = instance.exports.mem;
      compressChunkFn = instance.exports.compressChunk;
      compressPartialFn = instance.exports.compressPartial;
      compressParentFn = instance.exports.compressParent;
      mem = new Uint8Array(wasmMem.buffer);
      mem32 = new Uint32Array(wasmMem.buffer);
      return true;
    } catch (e) {
      console.warn("Fast SIMD init failed:", e);
      return false;
    }
  }
  function processChunk(chunk, counter, extraFlags = 0) {
    mem.set(chunk, OFF_INPUT);
    mem32[OFF_META / 4] = Number(counter & 0xffffffffn);
    mem32[OFF_META / 4 + 1] = Number(counter >> 32n & 0xffffffffn);
    mem32[OFF_META / 4 + 3] = extraFlags;
    compressChunkFn();
    return new Uint32Array(mem32.buffer, OFF_OUTPUT, 8).slice();
  }
  function processPartial(chunk, counter, extraFlags = 0) {
    mem.fill(0, OFF_INPUT, OFF_INPUT + CHUNK_LEN);
    mem.set(chunk, OFF_INPUT);
    mem32[OFF_META / 4] = Number(counter & 0xffffffffn);
    mem32[OFF_META / 4 + 1] = Number(counter >> 32n & 0xffffffffn);
    mem32[OFF_META / 4 + 2] = chunk.length;
    mem32[OFF_META / 4 + 3] = extraFlags;
    compressPartialFn();
    return new Uint32Array(mem32.buffer, OFF_OUTPUT, 8).slice();
  }
  function computeParent(left, right, flags) {
    for (let i = 0; i < 8; i++) {
      mem32[OFF_PARENT / 4 + i] = left[i];
      mem32[OFF_PARENT / 4 + 8 + i] = right[i];
    }
    mem32[OFF_META / 4 + 2] = flags;
    compressParentFn();
    return new Uint32Array(mem32.buffer, OFF_OUTPUT, 8).slice();
  }
  function cvToBytes(cv, len) {
    const out = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      out[i] = cv[i >>> 2] >>> ((i & 3) << 3) & 255;
    }
    return out;
  }
  function hash4(input, outLen = OUT_LEN) {
    if (!initWasm2())
      throw new Error("Fast SIMD not available");
    if (input.length === 0) {
      const cv = processPartial(new Uint8Array(0), 0n, ROOT);
      return cvToBytes(cv, outLen);
    }
    if (input.length <= CHUNK_LEN) {
      const cv = input.length === CHUNK_LEN ? processChunk(input, 0n, ROOT) : processPartial(input, 0n, ROOT);
      return cvToBytes(cv, outLen);
    }
    const cvStack = [];
    const totalChunks = Math.ceil(input.length / CHUNK_LEN);
    let chunkCounter = 0n;
    let pos = 0;
    while (pos + CHUNK_LEN <= input.length) {
      cvStack.push(
        processChunk(input.subarray(pos, pos + CHUNK_LEN), chunkCounter)
      );
      chunkCounter++;
      const isLast = Number(chunkCounter) === totalChunks;
      let merge = ctz64(chunkCounter);
      while (merge > 0 && cvStack.length >= 2) {
        if (isLast && cvStack.length === 2)
          break;
        const r = cvStack.pop(), l = cvStack.pop();
        cvStack.push(computeParent(l, r, 0));
        merge--;
      }
      pos += CHUNK_LEN;
    }
    if (pos < input.length) {
      cvStack.push(processPartial(input.subarray(pos), chunkCounter));
    }
    while (cvStack.length > 1) {
      const r = cvStack.pop(), l = cvStack.pop();
      const flags = cvStack.length === 0 ? ROOT : 0;
      cvStack.push(computeParent(l, r, flags));
    }
    return cvToBytes(cvStack[0], outLen);
  }

  // src/simd-4-fast.ts
  var SIMD_SUPPORTED3 = (() => {
    if (typeof WebAssembly === "undefined")
      return false;
    try {
      return WebAssembly.validate(
        new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          5,
          1,
          96,
          0,
          1,
          123,
          3,
          2,
          1,
          0,
          10,
          22,
          1,
          20,
          0,
          253,
          12,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          11
        ])
      );
    } catch {
      return false;
    }
  })();
  var SCHED2 = [
    [
      [0, 2, 4, 6],
      [1, 3, 5, 7],
      [8, 10, 12, 14],
      [9, 11, 13, 15]
    ],
    [
      [2, 3, 7, 4],
      [6, 10, 0, 13],
      [1, 12, 9, 15],
      [11, 5, 14, 8]
    ],
    [
      [3, 10, 13, 7],
      [4, 12, 2, 14],
      [6, 9, 11, 8],
      [5, 0, 15, 1]
    ],
    [
      [10, 12, 14, 13],
      [7, 9, 3, 15],
      [4, 11, 5, 1],
      [0, 2, 8, 6]
    ],
    [
      [12, 9, 15, 14],
      [13, 11, 10, 8],
      [7, 5, 0, 6],
      [2, 3, 1, 4]
    ],
    [
      [9, 11, 8, 15],
      [14, 5, 12, 1],
      [13, 0, 2, 4],
      [3, 10, 6, 7]
    ],
    [
      [11, 5, 1, 8],
      [15, 0, 9, 6],
      [14, 2, 3, 7],
      [10, 12, 4, 13]
    ]
  ];
  var ROTR162 = [2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13];
  var ROTR82 = [1, 2, 3, 0, 5, 6, 7, 4, 9, 10, 11, 8, 13, 14, 15, 12];
  var OFF_CHUNKS = 0;
  var OFF_COUNTERS = 4096;
  var OFF_META2 = 4128;
  var OFF_CVS = 4160;
  var OFF_SCRATCH = 4288;
  var CV_POOL = new Uint32Array(64 * 8);
  var CV_VIEWS = [];
  for (let i = 0; i < 64; i++) {
    CV_VIEWS.push(CV_POOL.subarray(i * 8, i * 8 + 8));
  }
  var TEMP_CVS = [
    // Receive 4 CVs from compress4
    new Uint32Array(8),
    new Uint32Array(8),
    new Uint32Array(8),
    new Uint32Array(8)
  ];
  var TEMP_LEFT = new Uint32Array(8);
  var TEMP_RIGHT = new Uint32Array(8);
  var W = class {
    constructor() {
      this.c = [];
    }
    emit(...b) {
      this.c.push(...b);
    }
    get(i) {
      this.emit(32, i);
    }
    // local.get
    set(i) {
      this.emit(33, i);
    }
    // local.set
    tee(i) {
      this.emit(34, i);
    }
    // local.tee
    // i32.const with signed LEB128 encoding
    i32c(v) {
      this.emit(65);
      let val = v, more = true;
      while (more) {
        let b = val & 127;
        val >>= 7;
        more = !(val === 0 && !(b & 64) || val === -1 && b & 64);
        if (more)
          b |= 128;
        this.emit(b);
      }
    }
    i32add() {
      this.emit(106);
    }
    i32sub() {
      this.emit(107);
    }
    i32mul() {
      this.emit(108);
    }
    i32divu() {
      this.emit(109);
    }
    i32or() {
      this.emit(114);
    }
    i32eq() {
      this.emit(70);
    }
    i32ltu() {
      this.emit(73);
    }
    i32ld(off) {
      this.emit(40, 2);
      this.uleb(off);
    }
    i32st(off) {
      this.emit(54, 2);
      this.uleb(off);
    }
    v128c(a, b, c, d) {
      this.emit(253, 12);
      for (const v of [a, b, c, d])
        this.emit(v & 255, v >> 8 & 255, v >> 16 & 255, v >> 24 & 255);
    }
    v128ld(off) {
      this.emit(253, 0, 4);
      this.uleb(off);
    }
    v128st(off) {
      this.emit(253, 11, 4);
      this.uleb(off);
    }
    v128xor() {
      this.emit(253, 81);
    }
    v128or() {
      this.emit(253, 80);
    }
    i32x4add() {
      this.emit(253, 174, 1);
    }
    i32x4shl() {
      this.emit(253, 171, 1);
    }
    i32x4shru() {
      this.emit(253, 173, 1);
    }
    shuffle(idx) {
      this.emit(253, 13, ...idx);
    }
    i32x4splat() {
      this.emit(253, 17);
    }
    i32x4replace(l) {
      this.emit(253, 28, l);
    }
    i32x4extract(l) {
      this.emit(253, 27, l);
    }
    block(f) {
      this.emit(2, 64);
      f();
      this.emit(11);
    }
    loop(f) {
      this.emit(3, 64);
      f();
      this.emit(11);
    }
    brif(d) {
      this.emit(13, d);
    }
    ifthen(f) {
      this.emit(4, 64);
      f();
      this.emit(11);
    }
    end() {
      this.emit(11);
    }
    uleb(v) {
      do {
        let b = v & 127;
        v >>>= 7;
        if (v)
          b |= 128;
        this.emit(b);
      } while (v);
    }
  };
  function buildCompress4() {
    const w = new W();
    const S = [];
    for (let i = 0; i < 16; i++)
      S.push(i);
    const MX = 16, MY = 17;
    const BIDX = 18;
    const ADDR = 19;
    for (let i = 0; i < 8; i++) {
      w.i32c(IV[i]);
      w.i32x4splat();
      w.set(S[i]);
    }
    w.i32c(0);
    w.set(BIDX);
    w.block(() => {
      w.loop(() => {
        for (let i = 0; i < 4; i++) {
          w.i32c(IV[i]);
          w.i32x4splat();
          w.set(S[8 + i]);
        }
        w.i32c(OFF_COUNTERS);
        w.i32ld(0);
        w.i32x4splat();
        w.i32c(OFF_COUNTERS);
        w.i32ld(8);
        w.i32x4replace(1);
        w.i32c(OFF_COUNTERS);
        w.i32ld(16);
        w.i32x4replace(2);
        w.i32c(OFF_COUNTERS);
        w.i32ld(24);
        w.i32x4replace(3);
        w.set(S[12]);
        w.i32c(OFF_COUNTERS);
        w.i32ld(4);
        w.i32x4splat();
        w.i32c(OFF_COUNTERS);
        w.i32ld(12);
        w.i32x4replace(1);
        w.i32c(OFF_COUNTERS);
        w.i32ld(20);
        w.i32x4replace(2);
        w.i32c(OFF_COUNTERS);
        w.i32ld(28);
        w.i32x4replace(3);
        w.set(S[13]);
        w.i32c(64);
        w.i32x4splat();
        w.set(S[14]);
        w.i32c(0);
        w.i32x4splat();
        w.set(S[15]);
        w.get(BIDX);
        w.i32c(0);
        w.i32eq();
        w.ifthen(() => {
          w.i32c(CHUNK_START);
          w.i32x4splat();
          w.set(S[15]);
        });
        w.get(BIDX);
        w.i32c(15);
        w.i32eq();
        w.ifthen(() => {
          w.get(S[15]);
          w.i32c(CHUNK_END);
          w.i32x4splat();
          w.v128or();
          w.i32c(OFF_META2);
          w.i32ld(4);
          w.i32x4splat();
          w.v128or();
          w.set(S[15]);
        });
        const gatherMsg = (wordIdx, dst) => {
          w.get(BIDX);
          w.i32c(256);
          w.i32mul();
          w.i32c(wordIdx * 16);
          w.i32add();
          w.v128ld(0);
          w.set(dst);
        };
        const G4 = (a, b, c, d, mx, my) => {
          w.get(S[a]);
          w.get(S[b]);
          w.i32x4add();
          w.get(mx);
          w.i32x4add();
          w.set(S[a]);
          w.get(S[d]);
          w.get(S[a]);
          w.v128xor();
          w.tee(S[d]);
          w.get(S[d]);
          w.shuffle(ROTR162);
          w.set(S[d]);
          w.get(S[c]);
          w.get(S[d]);
          w.i32x4add();
          w.set(S[c]);
          w.get(S[b]);
          w.get(S[c]);
          w.v128xor();
          w.tee(S[b]);
          w.i32c(12);
          w.i32x4shru();
          w.get(S[b]);
          w.i32c(20);
          w.i32x4shl();
          w.v128or();
          w.set(S[b]);
          w.get(S[a]);
          w.get(S[b]);
          w.i32x4add();
          w.get(my);
          w.i32x4add();
          w.set(S[a]);
          w.get(S[d]);
          w.get(S[a]);
          w.v128xor();
          w.tee(S[d]);
          w.get(S[d]);
          w.shuffle(ROTR82);
          w.set(S[d]);
          w.get(S[c]);
          w.get(S[d]);
          w.i32x4add();
          w.set(S[c]);
          w.get(S[b]);
          w.get(S[c]);
          w.v128xor();
          w.tee(S[b]);
          w.i32c(7);
          w.i32x4shru();
          w.get(S[b]);
          w.i32c(25);
          w.i32x4shl();
          w.v128or();
          w.set(S[b]);
        };
        for (let r = 0; r < 7; r++) {
          const [colMx, colMy, diagMx, diagMy] = SCHED2[r];
          gatherMsg(colMx[0], MX);
          gatherMsg(colMy[0], MY);
          G4(0, 4, 8, 12, MX, MY);
          gatherMsg(colMx[1], MX);
          gatherMsg(colMy[1], MY);
          G4(1, 5, 9, 13, MX, MY);
          gatherMsg(colMx[2], MX);
          gatherMsg(colMy[2], MY);
          G4(2, 6, 10, 14, MX, MY);
          gatherMsg(colMx[3], MX);
          gatherMsg(colMy[3], MY);
          G4(3, 7, 11, 15, MX, MY);
          gatherMsg(diagMx[0], MX);
          gatherMsg(diagMy[0], MY);
          G4(0, 5, 10, 15, MX, MY);
          gatherMsg(diagMx[1], MX);
          gatherMsg(diagMy[1], MY);
          G4(1, 6, 11, 12, MX, MY);
          gatherMsg(diagMx[2], MX);
          gatherMsg(diagMy[2], MY);
          G4(2, 7, 8, 13, MX, MY);
          gatherMsg(diagMx[3], MX);
          gatherMsg(diagMy[3], MY);
          G4(3, 4, 9, 14, MX, MY);
        }
        for (let i = 0; i < 8; i++) {
          w.get(S[i]);
          w.get(S[i + 8]);
          w.v128xor();
          w.set(S[i]);
        }
        w.get(BIDX);
        w.i32c(1);
        w.i32add();
        w.set(BIDX);
        w.get(BIDX);
        w.i32c(16);
        w.i32ltu();
        w.brif(0);
      });
    });
    for (let c = 0; c < 4; c++) {
      for (let i = 0; i < 8; i += 4) {
        w.i32c(OFF_CVS + c * 32 + i * 4);
        w.get(S[i]);
        w.i32x4extract(c);
        w.i32x4splat();
        w.get(S[i + 1]);
        w.i32x4extract(c);
        w.i32x4replace(1);
        w.get(S[i + 2]);
        w.i32x4extract(c);
        w.i32x4replace(2);
        w.get(S[i + 3]);
        w.i32x4extract(c);
        w.i32x4replace(3);
        w.v128st(0);
      }
    }
    w.end();
    return w.c;
  }
  function buildCompress1() {
    const w = new W();
    const S = [];
    for (let i = 0; i < 16; i++)
      S.push(i);
    const MX = 16, MY = 17;
    const CV0 = 18, CV1 = 19;
    const BIDX = 20, MSGPTR = 21, FLAGS = 22;
    w.v128c(IV[0], IV[1], IV[2], IV[3]);
    w.set(CV0);
    w.v128c(IV[4], IV[5], IV[6], IV[7]);
    w.set(CV1);
    w.i32c(0);
    w.set(BIDX);
    w.i32c(0);
    w.set(MSGPTR);
    w.block(() => {
      w.loop(() => {
        w.get(CV0);
        w.set(S[0]);
        w.get(CV1);
        w.set(S[1]);
        w.v128c(IV[0], IV[1], IV[2], IV[3]);
        w.set(S[2]);
        w.i32c(0);
        w.set(FLAGS);
        w.get(BIDX);
        w.i32c(0);
        w.i32eq();
        w.ifthen(() => {
          w.get(FLAGS);
          w.i32c(CHUNK_START);
          w.i32or();
          w.set(FLAGS);
        });
        w.get(BIDX);
        w.i32c(15);
        w.i32eq();
        w.ifthen(() => {
          w.get(FLAGS);
          w.i32c(CHUNK_END);
          w.i32or();
          w.i32c(OFF_META2);
          w.i32ld(4);
          w.i32or();
          w.set(FLAGS);
        });
        w.i32c(OFF_COUNTERS);
        w.i32ld(0);
        w.i32x4splat();
        w.i32c(OFF_COUNTERS);
        w.i32ld(4);
        w.i32x4replace(1);
        w.i32c(64);
        w.i32x4replace(2);
        w.get(FLAGS);
        w.i32x4replace(3);
        w.set(S[3]);
        const gatherRow = (i0, i1, i2, i3, dst) => {
          w.get(MSGPTR);
          w.i32ld(i0 * 4);
          w.i32x4splat();
          w.get(MSGPTR);
          w.i32ld(i1 * 4);
          w.i32x4replace(1);
          w.get(MSGPTR);
          w.i32ld(i2 * 4);
          w.i32x4replace(2);
          w.get(MSGPTR);
          w.i32ld(i3 * 4);
          w.i32x4replace(3);
          w.set(dst);
        };
        const gHalf = (m, rot1, rot2) => {
          w.get(S[0]);
          w.get(S[1]);
          w.i32x4add();
          w.get(m);
          w.i32x4add();
          w.set(S[0]);
          w.get(S[3]);
          w.get(S[0]);
          w.v128xor();
          if (rot1 === 16) {
            w.tee(S[3]);
            w.get(S[3]);
            w.shuffle(ROTR162);
          } else {
            w.tee(S[3]);
            w.get(S[3]);
            w.shuffle(ROTR82);
          }
          w.set(S[3]);
          w.get(S[2]);
          w.get(S[3]);
          w.i32x4add();
          w.set(S[2]);
          w.get(S[1]);
          w.get(S[2]);
          w.v128xor();
          w.tee(S[1]);
          w.i32c(rot2);
          w.i32x4shru();
          w.get(S[1]);
          w.i32c(32 - rot2);
          w.i32x4shl();
          w.v128or();
          w.set(S[1]);
        };
        const ROT1_L2 = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3];
        const ROT2_L2 = [8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7];
        const ROT3_L2 = [12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        const ROT1_R2 = [12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        const ROT2_R2 = [8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7];
        const ROT3_R2 = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3];
        const rotateDiag = () => {
          w.get(S[1]);
          w.get(S[1]);
          w.shuffle(ROT1_L2);
          w.set(S[1]);
          w.get(S[2]);
          w.get(S[2]);
          w.shuffle(ROT2_L2);
          w.set(S[2]);
          w.get(S[3]);
          w.get(S[3]);
          w.shuffle(ROT3_L2);
          w.set(S[3]);
        };
        const unrotateDiag = () => {
          w.get(S[1]);
          w.get(S[1]);
          w.shuffle(ROT1_R2);
          w.set(S[1]);
          w.get(S[2]);
          w.get(S[2]);
          w.shuffle(ROT2_R2);
          w.set(S[2]);
          w.get(S[3]);
          w.get(S[3]);
          w.shuffle(ROT3_R2);
          w.set(S[3]);
        };
        for (let r = 0; r < 7; r++) {
          const [colMx, colMy, diagMx, diagMy] = SCHED2[r];
          gatherRow(colMx[0], colMx[1], colMx[2], colMx[3], MX);
          gatherRow(colMy[0], colMy[1], colMy[2], colMy[3], MY);
          gHalf(MX, 16, 12);
          gHalf(MY, 8, 7);
          rotateDiag();
          gatherRow(diagMx[0], diagMx[1], diagMx[2], diagMx[3], MX);
          gatherRow(diagMy[0], diagMy[1], diagMy[2], diagMy[3], MY);
          gHalf(MX, 16, 12);
          gHalf(MY, 8, 7);
          unrotateDiag();
        }
        w.get(S[0]);
        w.get(S[2]);
        w.v128xor();
        w.set(CV0);
        w.get(S[1]);
        w.get(S[3]);
        w.v128xor();
        w.set(CV1);
        w.get(BIDX);
        w.i32c(1);
        w.i32add();
        w.set(BIDX);
        w.get(MSGPTR);
        w.i32c(64);
        w.i32add();
        w.set(MSGPTR);
        w.get(BIDX);
        w.i32c(16);
        w.i32ltu();
        w.brif(0);
      });
    });
    w.i32c(OFF_CVS);
    w.get(CV0);
    w.v128st(0);
    w.i32c(OFF_CVS);
    w.get(CV1);
    w.v128st(16);
    w.end();
    return w.c;
  }
  function buildParent() {
    const w = new W();
    const S0 = 0, S1 = 1, S2 = 2, S3 = 3, MX = 4, MY = 5;
    w.v128c(IV[0], IV[1], IV[2], IV[3]);
    w.set(S0);
    w.v128c(IV[4], IV[5], IV[6], IV[7]);
    w.set(S1);
    w.v128c(IV[0], IV[1], IV[2], IV[3]);
    w.set(S2);
    w.i32c(0);
    w.i32x4splat();
    w.i32c(64);
    w.i32x4replace(2);
    w.i32c(OFF_META2);
    w.i32ld(4);
    w.i32c(PARENT);
    w.i32or();
    w.i32x4replace(3);
    w.set(S3);
    const gatherRow = (i0, i1, i2, i3, dst) => {
      w.i32c(OFF_SCRATCH);
      w.i32ld(i0 * 4);
      w.i32x4splat();
      w.i32c(OFF_SCRATCH);
      w.i32ld(i1 * 4);
      w.i32x4replace(1);
      w.i32c(OFF_SCRATCH);
      w.i32ld(i2 * 4);
      w.i32x4replace(2);
      w.i32c(OFF_SCRATCH);
      w.i32ld(i3 * 4);
      w.i32x4replace(3);
      w.set(dst);
    };
    const gHalf = (m, rot1, rot2) => {
      w.get(S0);
      w.get(S1);
      w.i32x4add();
      w.get(m);
      w.i32x4add();
      w.set(S0);
      w.get(S3);
      w.get(S0);
      w.v128xor();
      if (rot1 === 16) {
        w.tee(S3);
        w.get(S3);
        w.shuffle(ROTR162);
      } else {
        w.tee(S3);
        w.get(S3);
        w.shuffle(ROTR82);
      }
      w.set(S3);
      w.get(S2);
      w.get(S3);
      w.i32x4add();
      w.set(S2);
      w.get(S1);
      w.get(S2);
      w.v128xor();
      w.tee(S1);
      w.i32c(rot2);
      w.i32x4shru();
      w.get(S1);
      w.i32c(32 - rot2);
      w.i32x4shl();
      w.v128or();
      w.set(S1);
    };
    const ROT1_L2 = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3];
    const ROT2_L2 = [8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7];
    const ROT3_L2 = [12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    const ROT1_R2 = [12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    const ROT2_R2 = [8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7];
    const ROT3_R2 = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3];
    const rotateDiag = () => {
      w.get(S1);
      w.get(S1);
      w.shuffle(ROT1_L2);
      w.set(S1);
      w.get(S2);
      w.get(S2);
      w.shuffle(ROT2_L2);
      w.set(S2);
      w.get(S3);
      w.get(S3);
      w.shuffle(ROT3_L2);
      w.set(S3);
    };
    const unrotateDiag = () => {
      w.get(S1);
      w.get(S1);
      w.shuffle(ROT1_R2);
      w.set(S1);
      w.get(S2);
      w.get(S2);
      w.shuffle(ROT2_R2);
      w.set(S2);
      w.get(S3);
      w.get(S3);
      w.shuffle(ROT3_R2);
      w.set(S3);
    };
    for (let r = 0; r < 7; r++) {
      const [colMx, colMy, diagMx, diagMy] = SCHED2[r];
      gatherRow(colMx[0], colMx[1], colMx[2], colMx[3], MX);
      gatherRow(colMy[0], colMy[1], colMy[2], colMy[3], MY);
      gHalf(MX, 16, 12);
      gHalf(MY, 8, 7);
      rotateDiag();
      gatherRow(diagMx[0], diagMx[1], diagMx[2], diagMx[3], MX);
      gatherRow(diagMy[0], diagMy[1], diagMy[2], diagMy[3], MY);
      gHalf(MX, 16, 12);
      gHalf(MY, 8, 7);
      unrotateDiag();
    }
    w.i32c(OFF_CVS);
    w.get(S0);
    w.get(S2);
    w.v128xor();
    w.v128st(0);
    w.i32c(OFF_CVS);
    w.get(S1);
    w.get(S3);
    w.v128xor();
    w.v128st(16);
    w.end();
    return w.c;
  }
  function generateModule2() {
    const mod = [];
    const put = (...b) => mod.push(...b);
    const uleb = (v) => {
      do {
        let b = v & 127;
        v >>>= 7;
        if (v)
          b |= 128;
        mod.push(b);
      } while (v);
    };
    const section = (id, data) => {
      mod.push(id);
      uleb(data.length);
      mod.push(...data);
    };
    put(0, 97, 115, 109, 1, 0, 0, 0);
    section(1, [1, 96, 0, 0]);
    section(3, [3, 0, 0, 0]);
    section(5, [1, 0, 1]);
    const exports = [4];
    const addExp = (name, kind, idx) => {
      exports.push(
        name.length,
        ...Array.from(name).map((c) => c.charCodeAt(0)),
        kind,
        idx
      );
    };
    addExp("compress4", 0, 0);
    addExp("compress1", 0, 1);
    addExp("parent", 0, 2);
    addExp("mem", 2, 0);
    section(7, exports);
    const code4 = buildCompress4();
    const code1 = buildCompress1();
    const codeP = buildParent();
    const encodeFunc = (code, nV128, nI32) => {
      const locals = [];
      let groups = 0;
      if (nV128 > 0) {
        locals.push(nV128, 123);
        groups++;
      }
      if (nI32 > 0) {
        locals.push(nI32, 127);
        groups++;
      }
      const body = [groups, ...locals, ...code];
      const lenBytes = [];
      let len = body.length;
      do {
        let b = len & 127;
        len >>>= 7;
        if (len)
          b |= 128;
        lenBytes.push(b);
      } while (len);
      return [...lenBytes, ...body];
    };
    const f0 = encodeFunc(code4, 18, 2);
    const f1 = encodeFunc(code1, 20, 3);
    const f2 = encodeFunc(codeP, 6, 0);
    section(10, [3, ...f0, ...f1, ...f2]);
    return new Uint8Array(mod);
  }
  var instance2 = null;
  var compress4Fn = null;
  var compress1Fn = null;
  var parentFn = null;
  var mem2 = null;
  var mem322 = null;
  function transpose4Chunks(src32, srcOffset, dst32, dstOffset) {
    let s = srcOffset;
    let d = dstOffset;
    for (let i = 0; i < 64; i++) {
      dst32[d] = src32[s];
      dst32[d + 1] = src32[s + 256];
      dst32[d + 2] = src32[s + 512];
      dst32[d + 3] = src32[s + 768];
      dst32[d + 4] = src32[s + 1];
      dst32[d + 5] = src32[s + 257];
      dst32[d + 6] = src32[s + 513];
      dst32[d + 7] = src32[s + 769];
      dst32[d + 8] = src32[s + 2];
      dst32[d + 9] = src32[s + 258];
      dst32[d + 10] = src32[s + 514];
      dst32[d + 11] = src32[s + 770];
      dst32[d + 12] = src32[s + 3];
      dst32[d + 13] = src32[s + 259];
      dst32[d + 14] = src32[s + 515];
      dst32[d + 15] = src32[s + 771];
      d += 16;
      s += 4;
    }
  }
  function initWasm3() {
    if (instance2)
      return true;
    if (!SIMD_SUPPORTED3)
      return false;
    try {
      const module = new WebAssembly.Module(generateModule2());
      instance2 = new WebAssembly.Instance(module);
      const wasmMem = instance2.exports.mem;
      compress4Fn = instance2.exports.compress4;
      compress1Fn = instance2.exports.compress1;
      parentFn = instance2.exports.parent;
      mem2 = new Uint8Array(wasmMem.buffer);
      mem322 = new Uint32Array(wasmMem.buffer);
      return true;
    } catch (e) {
      console.warn("4-Fast SIMD init failed:", e);
      return false;
    }
  }
  function process4Fast(input, inputOffset, counter, extraFlags = 0) {
    const inputBase = inputOffset + (input.byteOffset || 0);
    if (inputBase % 4 === 0) {
      const src32 = new Uint32Array(input.buffer, inputBase, CHUNK_LEN);
      transpose4Chunks(src32, 0, mem322, OFF_CHUNKS / 4);
    } else {
      const tmp = new Uint8Array(4 * CHUNK_LEN);
      tmp.set(input.subarray(inputOffset, inputOffset + 4 * CHUNK_LEN));
      const src32 = new Uint32Array(tmp.buffer);
      transpose4Chunks(src32, 0, mem322, OFF_CHUNKS / 4);
    }
    const counterBase = OFF_COUNTERS / 4;
    mem322[counterBase] = counter;
    mem322[counterBase + 1] = 0;
    mem322[counterBase + 2] = counter + 1;
    mem322[counterBase + 3] = 0;
    mem322[counterBase + 4] = counter + 2;
    mem322[counterBase + 5] = 0;
    mem322[counterBase + 6] = counter + 3;
    mem322[counterBase + 7] = 0;
    mem322[OFF_META2 / 4 + 1] = extraFlags;
    compress4Fn();
    TEMP_CVS[0].set(new Uint32Array(mem322.buffer, OFF_CVS, 8));
    TEMP_CVS[1].set(new Uint32Array(mem322.buffer, OFF_CVS + 32, 8));
    TEMP_CVS[2].set(new Uint32Array(mem322.buffer, OFF_CVS + 64, 8));
    TEMP_CVS[3].set(new Uint32Array(mem322.buffer, OFF_CVS + 96, 8));
  }
  var PROCESS4_SCRATCH = new Uint8Array(4 * CHUNK_LEN);
  var PROCESS4_SCRATCH32 = new Uint32Array(PROCESS4_SCRATCH.buffer);
  function process4(c0, c1, c2, c3, cnt0, cnt1, cnt2, cnt3, extraFlags = 0) {
    PROCESS4_SCRATCH.set(c0, 0);
    PROCESS4_SCRATCH.set(c1, 1024);
    PROCESS4_SCRATCH.set(c2, 2048);
    PROCESS4_SCRATCH.set(c3, 3072);
    transpose4Chunks(PROCESS4_SCRATCH32, 0, mem322, OFF_CHUNKS / 4);
    mem322[OFF_COUNTERS / 4] = Number(cnt0 & 0xffffffffn);
    mem322[OFF_COUNTERS / 4 + 1] = Number(cnt0 >> 32n & 0xffffffffn);
    mem322[OFF_COUNTERS / 4 + 2] = Number(cnt1 & 0xffffffffn);
    mem322[OFF_COUNTERS / 4 + 3] = Number(cnt1 >> 32n & 0xffffffffn);
    mem322[OFF_COUNTERS / 4 + 4] = Number(cnt2 & 0xffffffffn);
    mem322[OFF_COUNTERS / 4 + 5] = Number(cnt2 >> 32n & 0xffffffffn);
    mem322[OFF_COUNTERS / 4 + 6] = Number(cnt3 & 0xffffffffn);
    mem322[OFF_COUNTERS / 4 + 7] = Number(cnt3 >> 32n & 0xffffffffn);
    mem322[OFF_META2 / 4 + 1] = extraFlags;
    compress4Fn();
    return [
      new Uint32Array(mem322.buffer, OFF_CVS, 8).slice(),
      new Uint32Array(mem322.buffer, OFF_CVS + 32, 8).slice(),
      new Uint32Array(mem322.buffer, OFF_CVS + 64, 8).slice(),
      new Uint32Array(mem322.buffer, OFF_CVS + 96, 8).slice()
    ];
  }
  function process1Fast(input, inputOffset, counter, extraFlags, dest) {
    mem2.set(input.subarray(inputOffset, inputOffset + CHUNK_LEN), OFF_CHUNKS);
    mem322[OFF_COUNTERS / 4] = counter;
    mem322[OFF_COUNTERS / 4 + 1] = 0;
    mem322[OFF_META2 / 4 + 1] = extraFlags;
    compress1Fn();
    dest.set(new Uint32Array(mem322.buffer, OFF_CVS, 8));
  }
  function process1(chunk, counter, extraFlags = 0) {
    mem2.fill(0, OFF_CHUNKS, OFF_CHUNKS + CHUNK_LEN);
    mem2.set(chunk, OFF_CHUNKS);
    mem322[OFF_COUNTERS / 4] = Number(counter & 0xffffffffn);
    mem322[OFF_COUNTERS / 4 + 1] = Number(counter >> 32n & 0xffffffffn);
    mem322[OFF_META2 / 4 + 1] = extraFlags;
    compress1Fn();
    return new Uint32Array(mem322.buffer, OFF_CVS, 8).slice();
  }
  function processPartialChunk(chunk, counter, extraFlags = 0) {
    const cv = new Uint32Array(IV);
    const numBlocks = Math.ceil(chunk.length / BLOCK_LEN) || 1;
    for (let b = 0; b < numBlocks; b++) {
      const blockStart = b * BLOCK_LEN;
      const blockEnd = Math.min(blockStart + BLOCK_LEN, chunk.length);
      const blockLen = blockEnd - blockStart;
      mem2.fill(0, OFF_SCRATCH, OFF_SCRATCH + BLOCK_LEN);
      if (blockLen > 0) {
        mem2.set(chunk.subarray(blockStart, blockEnd), OFF_SCRATCH);
      }
      let flags = 0;
      if (b === 0)
        flags |= CHUNK_START;
      if (b === numBlocks - 1) {
        flags |= CHUNK_END;
        flags |= extraFlags;
      }
      const state = compressBlockJS(
        cv,
        mem2.subarray(OFF_SCRATCH, OFF_SCRATCH + BLOCK_LEN),
        counter,
        blockLen,
        flags
      );
      cv.set(state.subarray(0, 8));
    }
    return cv;
  }
  function compressBlockJS(cv, block, counter, blockLen, flags) {
    const m = new Uint32Array(16);
    for (let i = 0; i < 16; i++) {
      m[i] = block[i * 4] | block[i * 4 + 1] << 8 | block[i * 4 + 2] << 16 | block[i * 4 + 3] << 24;
    }
    const s = new Uint32Array([
      cv[0],
      cv[1],
      cv[2],
      cv[3],
      cv[4],
      cv[5],
      cv[6],
      cv[7],
      IV[0],
      IV[1],
      IV[2],
      IV[3],
      Number(counter & 0xffffffffn),
      Number(counter >> 32n & 0xffffffffn),
      blockLen,
      flags
    ]);
    const schedules = [
      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
      [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8],
      [3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1],
      [10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6],
      [12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4],
      [9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7],
      [11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13]
    ];
    const rotr = (x, n) => (x >>> n | x << 32 - n) >>> 0;
    const g2 = (a, b, c, d, mx, my) => {
      s[a] = s[a] + s[b] + mx >>> 0;
      s[d] = rotr(s[d] ^ s[a], 16);
      s[c] = s[c] + s[d] >>> 0;
      s[b] = rotr(s[b] ^ s[c], 12);
      s[a] = s[a] + s[b] + my >>> 0;
      s[d] = rotr(s[d] ^ s[a], 8);
      s[c] = s[c] + s[d] >>> 0;
      s[b] = rotr(s[b] ^ s[c], 7);
    };
    for (let round2 = 0; round2 < 7; round2++) {
      const sched = schedules[round2];
      g2(0, 4, 8, 12, m[sched[0]], m[sched[1]]);
      g2(1, 5, 9, 13, m[sched[2]], m[sched[3]]);
      g2(2, 6, 10, 14, m[sched[4]], m[sched[5]]);
      g2(3, 7, 11, 15, m[sched[6]], m[sched[7]]);
      g2(0, 5, 10, 15, m[sched[8]], m[sched[9]]);
      g2(1, 6, 11, 12, m[sched[10]], m[sched[11]]);
      g2(2, 7, 8, 13, m[sched[12]], m[sched[13]]);
      g2(3, 4, 9, 14, m[sched[14]], m[sched[15]]);
    }
    for (let i = 0; i < 8; i++) {
      s[i] ^= s[i + 8];
    }
    return s;
  }
  function computeParentFast(left, right, flags, dest) {
    const base = OFF_SCRATCH / 4;
    for (let i = 0; i < 8; i++) {
      mem322[base + i] = left[i];
      mem322[base + 8 + i] = right[i];
    }
    mem322[OFF_META2 / 4 + 1] = flags;
    parentFn();
    dest.set(new Uint32Array(mem322.buffer, OFF_CVS, 8));
  }
  function computeParent2(left, right, flags) {
    for (let i = 0; i < 8; i++) {
      mem322[OFF_SCRATCH / 4 + i] = left[i];
      mem322[OFF_SCRATCH / 4 + 8 + i] = right[i];
    }
    mem322[OFF_META2 / 4 + 1] = flags;
    parentFn();
    return new Uint32Array(mem322.buffer, OFF_CVS, 8).slice();
  }
  function cvToBytes2(cv, len) {
    const out = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      out[i] = cv[i >>> 2] >>> ((i & 3) << 3) & 255;
    }
    return out;
  }
  function hash5(input, outLen = OUT_LEN) {
    if (!initWasm3()) {
      throw new Error("4-Fast SIMD not available");
    }
    if (input.length === 0) {
      const cv = processPartialChunk(new Uint8Array(0), 0n, ROOT);
      return cvToBytes2(cv, outLen);
    }
    if (input.length <= CHUNK_LEN) {
      if (input.length === CHUNK_LEN) {
        const cv = process1(input, 0n, ROOT);
        return cvToBytes2(cv, outLen);
      } else {
        const cv = processPartialChunk(input, 0n, ROOT);
        return cvToBytes2(cv, outLen);
      }
    }
    const cvStack = [];
    const totalChunks = Math.ceil(input.length / CHUNK_LEN);
    let chunkCounter = 0n;
    let pos = 0;
    while (pos + 4 * CHUNK_LEN <= input.length) {
      const cvs = process4(
        input.subarray(pos, pos + CHUNK_LEN),
        input.subarray(pos + CHUNK_LEN, pos + 2 * CHUNK_LEN),
        input.subarray(pos + 2 * CHUNK_LEN, pos + 3 * CHUNK_LEN),
        input.subarray(pos + 3 * CHUNK_LEN, pos + 4 * CHUNK_LEN),
        chunkCounter,
        chunkCounter + 1n,
        chunkCounter + 2n,
        chunkCounter + 3n
      );
      for (let i = 0; i < 4; i++) {
        cvStack.push(cvs[i]);
        chunkCounter++;
        const isLast = Number(chunkCounter) === totalChunks;
        let merge = ctz64(chunkCounter);
        while (merge > 0 && cvStack.length >= 2) {
          if (isLast && cvStack.length === 2)
            break;
          const r = cvStack.pop(), l = cvStack.pop();
          cvStack.push(computeParent2(l, r, 0));
          merge--;
        }
      }
      pos += 4 * CHUNK_LEN;
    }
    while (pos + CHUNK_LEN <= input.length) {
      cvStack.push(process1(input.subarray(pos, pos + CHUNK_LEN), chunkCounter));
      chunkCounter++;
      const isLast = Number(chunkCounter) === totalChunks;
      let merge = ctz64(chunkCounter);
      while (merge > 0 && cvStack.length >= 2) {
        if (isLast && cvStack.length === 2)
          break;
        const r = cvStack.pop(), l = cvStack.pop();
        cvStack.push(computeParent2(l, r, 0));
        merge--;
      }
      pos += CHUNK_LEN;
    }
    if (pos < input.length) {
      const partial = input.subarray(pos);
      cvStack.push(processPartialChunk(partial, chunkCounter, 0));
    }
    while (cvStack.length > 1) {
      const r = cvStack.pop(), l = cvStack.pop();
      const flags = cvStack.length === 0 ? ROOT : 0;
      cvStack.push(computeParent2(l, r, flags));
    }
    return cvToBytes2(cvStack[0], outLen);
  }
  function hashFast(input, outLen = OUT_LEN) {
    if (!initWasm3()) {
      throw new Error("4-Fast SIMD not available");
    }
    if (input.length === 0) {
      const cv = processPartialChunk(new Uint8Array(0), 0n, ROOT);
      return cvToBytes2(cv, outLen);
    }
    if (input.length <= CHUNK_LEN) {
      if (input.length === CHUNK_LEN) {
        process1Fast(input, 0, 0, ROOT, CV_VIEWS[0]);
        return cvToBytes2(CV_VIEWS[0], outLen);
      } else {
        const cv = processPartialChunk(input, 0n, ROOT);
        return cvToBytes2(cv, outLen);
      }
    }
    const totalChunks = Math.ceil(input.length / CHUNK_LEN);
    let cvStackLen = 0;
    let chunkCounter = 0;
    let pos = 0;
    while (pos + 4 * CHUNK_LEN <= input.length) {
      process4Fast(input, pos, chunkCounter, 0);
      for (let i = 0; i < 4; i++) {
        CV_VIEWS[cvStackLen].set(TEMP_CVS[i]);
        cvStackLen++;
        chunkCounter++;
        const isLast = chunkCounter === totalChunks;
        let merge = ctz32(chunkCounter);
        while (merge > 0 && cvStackLen >= 2) {
          if (isLast && cvStackLen === 2)
            break;
          cvStackLen--;
          TEMP_RIGHT.set(CV_VIEWS[cvStackLen]);
          cvStackLen--;
          TEMP_LEFT.set(CV_VIEWS[cvStackLen]);
          computeParentFast(TEMP_LEFT, TEMP_RIGHT, 0, CV_VIEWS[cvStackLen]);
          cvStackLen++;
          merge--;
        }
      }
      pos += 4 * CHUNK_LEN;
    }
    while (pos + CHUNK_LEN <= input.length) {
      process1Fast(input, pos, chunkCounter, 0, CV_VIEWS[cvStackLen]);
      cvStackLen++;
      chunkCounter++;
      const isLast = chunkCounter === totalChunks;
      let merge = ctz32(chunkCounter);
      while (merge > 0 && cvStackLen >= 2) {
        if (isLast && cvStackLen === 2)
          break;
        cvStackLen--;
        TEMP_RIGHT.set(CV_VIEWS[cvStackLen]);
        cvStackLen--;
        TEMP_LEFT.set(CV_VIEWS[cvStackLen]);
        computeParentFast(TEMP_LEFT, TEMP_RIGHT, 0, CV_VIEWS[cvStackLen]);
        cvStackLen++;
        merge--;
      }
      pos += CHUNK_LEN;
    }
    if (pos < input.length) {
      const partial = input.subarray(pos);
      const cv = processPartialChunk(partial, BigInt(chunkCounter), 0);
      CV_VIEWS[cvStackLen].set(cv);
      cvStackLen++;
    }
    while (cvStackLen > 1) {
      cvStackLen--;
      TEMP_RIGHT.set(CV_VIEWS[cvStackLen]);
      cvStackLen--;
      TEMP_LEFT.set(CV_VIEWS[cvStackLen]);
      const flags = cvStackLen === 0 ? ROOT : 0;
      computeParentFast(TEMP_LEFT, TEMP_RIGHT, flags, CV_VIEWS[cvStackLen]);
      cvStackLen++;
    }
    return cvToBytes2(CV_VIEWS[0], outLen);
  }
  var CTZ_TABLE = new Uint8Array([
    0,
    1,
    28,
    2,
    29,
    14,
    24,
    3,
    30,
    22,
    20,
    15,
    25,
    17,
    4,
    8,
    31,
    27,
    13,
    23,
    21,
    19,
    16,
    7,
    26,
    12,
    18,
    6,
    11,
    5,
    10,
    9
  ]);
  function ctz32(n) {
    if (n === 0)
      return 32;
    return CTZ_TABLE[(n & -n) * 125613361 >>> 27 & 31];
  }
  var HYPER_CV_STACK = new Uint32Array(64 * 8);
  var SCRATCH_BASE = OFF_SCRATCH / 4;
  var CVS_BASE = OFF_CVS / 4;
  var META_FLAGS = OFF_META2 / 4 + 1;
  var COUNTER_BASE = OFF_COUNTERS / 4;
  function computeParentFromStack(leftIdx, rightIdx, flags, destIdx) {
    const leftOff = leftIdx * 8;
    const rightOff = rightIdx * 8;
    const destOff = destIdx * 8;
    mem322[SCRATCH_BASE] = HYPER_CV_STACK[leftOff];
    mem322[SCRATCH_BASE + 1] = HYPER_CV_STACK[leftOff + 1];
    mem322[SCRATCH_BASE + 2] = HYPER_CV_STACK[leftOff + 2];
    mem322[SCRATCH_BASE + 3] = HYPER_CV_STACK[leftOff + 3];
    mem322[SCRATCH_BASE + 4] = HYPER_CV_STACK[leftOff + 4];
    mem322[SCRATCH_BASE + 5] = HYPER_CV_STACK[leftOff + 5];
    mem322[SCRATCH_BASE + 6] = HYPER_CV_STACK[leftOff + 6];
    mem322[SCRATCH_BASE + 7] = HYPER_CV_STACK[leftOff + 7];
    mem322[SCRATCH_BASE + 8] = HYPER_CV_STACK[rightOff];
    mem322[SCRATCH_BASE + 9] = HYPER_CV_STACK[rightOff + 1];
    mem322[SCRATCH_BASE + 10] = HYPER_CV_STACK[rightOff + 2];
    mem322[SCRATCH_BASE + 11] = HYPER_CV_STACK[rightOff + 3];
    mem322[SCRATCH_BASE + 12] = HYPER_CV_STACK[rightOff + 4];
    mem322[SCRATCH_BASE + 13] = HYPER_CV_STACK[rightOff + 5];
    mem322[SCRATCH_BASE + 14] = HYPER_CV_STACK[rightOff + 6];
    mem322[SCRATCH_BASE + 15] = HYPER_CV_STACK[rightOff + 7];
    mem322[META_FLAGS] = flags;
    parentFn();
    HYPER_CV_STACK[destOff] = mem322[CVS_BASE];
    HYPER_CV_STACK[destOff + 1] = mem322[CVS_BASE + 1];
    HYPER_CV_STACK[destOff + 2] = mem322[CVS_BASE + 2];
    HYPER_CV_STACK[destOff + 3] = mem322[CVS_BASE + 3];
    HYPER_CV_STACK[destOff + 4] = mem322[CVS_BASE + 4];
    HYPER_CV_STACK[destOff + 5] = mem322[CVS_BASE + 5];
    HYPER_CV_STACK[destOff + 6] = mem322[CVS_BASE + 6];
    HYPER_CV_STACK[destOff + 7] = mem322[CVS_BASE + 7];
  }
  function storeCVToStack(cvIdx, stackPos) {
    const base = CVS_BASE + cvIdx * 8;
    const destOff = stackPos * 8;
    HYPER_CV_STACK[destOff] = mem322[base];
    HYPER_CV_STACK[destOff + 1] = mem322[base + 1];
    HYPER_CV_STACK[destOff + 2] = mem322[base + 2];
    HYPER_CV_STACK[destOff + 3] = mem322[base + 3];
    HYPER_CV_STACK[destOff + 4] = mem322[base + 4];
    HYPER_CV_STACK[destOff + 5] = mem322[base + 5];
    HYPER_CV_STACK[destOff + 6] = mem322[base + 6];
    HYPER_CV_STACK[destOff + 7] = mem322[base + 7];
  }
  function hashHyper(input, outLen = OUT_LEN) {
    if (!initWasm3()) {
      throw new Error("SIMD not available");
    }
    if (input.length <= CHUNK_LEN) {
      if (input.length === 0) {
        const cv2 = processPartialChunk(new Uint8Array(0), 0n, ROOT);
        return cvToBytes2(cv2, outLen);
      }
      if (input.length === CHUNK_LEN) {
        process1Fast(input, 0, 0, ROOT, CV_VIEWS[0]);
        return cvToBytes2(CV_VIEWS[0], outLen);
      }
      const cv = processPartialChunk(input, 0n, ROOT);
      return cvToBytes2(cv, outLen);
    }
    const totalChunks = Math.ceil(input.length / CHUNK_LEN);
    let cvStackLen = 0;
    let chunkCounter = 0;
    let pos = 0;
    let input32 = null;
    if (input.byteOffset % 4 === 0 && input.byteLength % 4 === 0) {
      input32 = new Uint32Array(
        input.buffer,
        input.byteOffset,
        input.byteLength / 4
      );
    }
    const processCV = () => {
      chunkCounter++;
      cvStackLen++;
      const isLast = chunkCounter === totalChunks;
      let merge = ctz32(chunkCounter);
      while (merge > 0 && cvStackLen >= 2) {
        if (isLast && cvStackLen === 2)
          break;
        cvStackLen -= 2;
        computeParentFromStack(cvStackLen, cvStackLen + 1, 0, cvStackLen);
        cvStackLen++;
        merge--;
      }
    };
    while (pos + 4 * CHUNK_LEN <= input.length) {
      if (input32) {
        transpose4Chunks(input32, pos / 4, mem322, OFF_CHUNKS / 4);
      } else {
        const tmp = new Uint8Array(4 * CHUNK_LEN);
        tmp.set(input.subarray(pos, pos + 4 * CHUNK_LEN));
        const src32 = new Uint32Array(tmp.buffer);
        transpose4Chunks(src32, 0, mem322, OFF_CHUNKS / 4);
      }
      mem322[COUNTER_BASE] = chunkCounter;
      mem322[COUNTER_BASE + 1] = 0;
      mem322[COUNTER_BASE + 2] = chunkCounter + 1;
      mem322[COUNTER_BASE + 3] = 0;
      mem322[COUNTER_BASE + 4] = chunkCounter + 2;
      mem322[COUNTER_BASE + 5] = 0;
      mem322[COUNTER_BASE + 6] = chunkCounter + 3;
      mem322[COUNTER_BASE + 7] = 0;
      mem322[META_FLAGS] = 0;
      compress4Fn();
      storeCVToStack(0, cvStackLen);
      processCV();
      storeCVToStack(1, cvStackLen);
      processCV();
      storeCVToStack(2, cvStackLen);
      processCV();
      storeCVToStack(3, cvStackLen);
      processCV();
      pos += 4 * CHUNK_LEN;
    }
    while (pos + CHUNK_LEN <= input.length) {
      mem2.set(input.subarray(pos, pos + CHUNK_LEN), OFF_CHUNKS);
      mem322[COUNTER_BASE] = chunkCounter;
      mem322[COUNTER_BASE + 1] = 0;
      mem322[META_FLAGS] = 0;
      compress1Fn();
      storeCVToStack(0, cvStackLen);
      processCV();
      pos += CHUNK_LEN;
    }
    if (pos < input.length) {
      const cv = processPartialChunk(
        input.subarray(pos),
        BigInt(chunkCounter),
        0
      );
      HYPER_CV_STACK.set(cv, cvStackLen * 8);
      cvStackLen++;
    }
    while (cvStackLen > 1) {
      cvStackLen -= 2;
      const flags = cvStackLen === 0 ? ROOT : 0;
      computeParentFromStack(cvStackLen, cvStackLen + 1, flags, cvStackLen);
      cvStackLen++;
    }
    const finalCV = HYPER_CV_STACK.subarray(0, 8);
    return cvToBytes2(finalCV, outLen);
  }
  return __toCommonJS(stdin_exports);
})();


const { referenceHash, optimizedHash, fastSimdHash, fast4SimdHash, ultraSimdHash, hyperSimdHash, SIMD_SUPPORTED, FAST_SIMD_SUPPORTED, FAST_4_SIMD_SUPPORTED } = BLAKE3;

// — init —
const tags = document.getElementById('tags');
const btn = document.getElementById('btn');
const out = document.getElementById('out');

tags.innerHTML = [
  ['Fast', FAST_SIMD_SUPPORTED],
  ['Fast-4', FAST_4_SIMD_SUPPORTED],
  ['Hyper', FAST_4_SIMD_SUPPORTED]
].map(([n, ok]) => `<span class="tag ${ok ? 'ok' : ''}">${n}: ${ok ? '✓' : '✗'}</span>`).join('');

// verify
try {
  const t = hyperSimdHash(new Uint8Array([1,2,3]));
  if (t.length === 32) btn.disabled = false;
} catch(e) { out.textContent = 'error: ' + e.message; }

// — benchmark —
const sizes = [[96,'96B'],[512,'512B'],[1024,'1KB'],[32768,'32KB'],[65536,'64KB'],[262144,'256KB'],[1048576,'1MB']];

function bench(fn, input, ms = 2000) {
  for (let i = 0; i < 5; i++) fn(input);
  const t0 = performance.now();
  let n = 0;
  while (performance.now() - t0 < ms) { fn(input); n++; }
  const dt = performance.now() - t0;
  return (input.length * n / dt) * 1000 / 1048576; // MB/s
}

function fmt(n) { return n.toFixed(1).padStart(7) + ' MB/s'; }

async function run() {
  btn.disabled = true;
  out.textContent = '';
  
  const header = '  size   │  reference │  optimized │    fast    │   fast-4   │   hyper    │  best';
  const sep    = '─────────┼────────────┼────────────┼────────────┼────────────┼────────────┼───────';
  out.innerHTML = '<span class="h">' + header + '</span>\n<span class="h">' + sep + '</span>\n';
  
  for (const [size, label] of sizes) {
    out.innerHTML += '<span class="h">' + label.padStart(7) + '  │</span> running...';
    await new Promise(r => setTimeout(r, 10));
    
    const input = new Uint8Array(size);
    for (let i = 0; i < size; i++) input[i] = Math.random() * 256 | 0;
    
    const ref = bench(referenceHash, input);
    const opt = bench(optimizedHash, input);
    const fast = bench(fastSimdHash, input);
    const fast4 = bench(fast4SimdHash, input);
    const hyper = bench(hyperSimdHash, input);
    
    const best = Math.max(ref, opt, fast, fast4, hyper);
    const ratio = (best / ref).toFixed(1) + 'x';
    
    const line = [ref, opt, fast, fast4, hyper].map((v, i) => {
      const s = v.toFixed(0).padStart(6) + ' MB/s';
      return v === best ? '<span class="best">' + s + '</span>' : '<span class="v">' + s + '</span>';
    }).join('<span class="h"> │</span>');
    
    out.innerHTML = out.innerHTML.replace(/running\.\.\..*/, '');
    out.innerHTML += line + '<span class="h"> │</span><span class="x">' + ratio.padStart(6) + '</span>\n';
  }
  
  out.innerHTML += '<span class="h">' + sep + '</span>';
  btn.disabled = false;
}

btn.onclick = run;
</script>
</body>
</html>